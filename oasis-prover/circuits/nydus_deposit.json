{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":8766929623636648874,"abi":{"parameters":[{"name":"user_key","type":{"kind":"field"},"visibility":"private"},{"name":"token_address","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"previous_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"main_c_tot","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"main_c_inner","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"main_c_outer","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"main_c_inner_point","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"main_c_outer_point","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_tot","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_inner","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_outer","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_inner_m","type":{"kind":"field"},"visibility":"private"},{"name":"personal_c_outer_m","type":{"kind":"field"},"visibility":"private"},{"name":"personal_c_outer_r","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"array","length":2,"type":{"kind":"field"}},{"kind":"array","length":5,"type":{"kind":"field"}},{"kind":"array","length":2,"type":{"kind":"field"}},{"kind":"array","length":2,"type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"1612527314196857042":{"error_kind":"string","string":"Main total commitment y verification failed"},"1829188810346778472":{"error_kind":"string","string":"Main total commitment x verification failed"},"4595064417801177898":{"error_kind":"string","string":"Main outer commitment x verification failed"},"4870430370618040774":{"error_kind":"string","string":"Decrypted y coordinate doesn't match personal_c_tot"},"5016858004930596942":{"error_kind":"string","string":"Total commitment verification failed"},"5953736523571907205":{"error_kind":"string","string":"Main outer commitment y verification failed"},"6662057465190892192":{"error_kind":"string","string":"Main inner commitment y verification failed"},"10612215498520620440":{"error_kind":"string","string":"Decrypted x coordinate doesn't match personal_c_tot"},"11045699237078081382":{"error_kind":"string","string":"Main inner commitment x verification failed"},"11740974266937565723":{"error_kind":"string","string":"Outer commitment verification failed"},"15653880448467002131":{"error_kind":"string","string":"Inner commitment y verification failed"},"17493575164725668030":{"error_kind":"string","string":"Inner commitment x verification failed"}}},"bytecode":"H4sIAAAAAAAA/+1dCZweRZV/nUBCEgiEHKioIEeABLWr7w73KQQSCIfckT65BUFAQMMtChgkXAmQhASQAAJiRFAkykpQ1BVFxWPXk3V1ZVFhXRVWcatCt6npmck3X/r/2v4M9fvVdE13z5v3/q/eUUd3G/RaGT+M6OcG9Svlqd2Lo216jpP5ViZsEZlWGAeu6bixF4hAuIGbWoFtZ4ET+GEc+mYoHDsTuRvaufla2UajZdYsnHxuu/Z8iuoJxdumsq5X4fXVor3NIO1ti3b5d5Nl3U7W7WXdQTvPhcGUtcLA97zQc31f/sw83829WP4WcvI5de11ZZlD0NUUTSeTB9HV1IqudpT17bK+Q9Z3FucHoq3TGz5E2qrjC1kthV1xvrw2jPqXKt5mvSJGE48NU3d8ik60dSyc4uiSBrZRXJhTOaduurjC1LAKc3U7rQuk5Q0dNDPvUHQcvAFwGN6dkjqVPp2pAw5JBxyEw6Qfs2YpjX+A+Ap3hk4XfHf6Xzq/PifDinjVwOoy7+MUKAKgvFwYBtS9p+/0fwPCenq03G4hd7d9pxNdpL5DIIa6c1Z0lXNuMvKPod6L/NOK404lICWA6kI18u9E/JF/JyCtnYkn8u9M/JF/DOEi/zQm/Zg1S5ORfxrxRP5dOBlWxNGRfxecAsWu1O7IrzDclfCRf1dqd+TfqZAbHfmR+t6NeCK/ott05Dep9yJ/SXOPEpASQHWhGvn3IP7IvweQ1p7EE/n3JP7IbxIu8u/OpB+zZmky8u9OPJF/L06GFXF05N8Lp0CxN7U78is6exM+8u9N7Y78exRyoyM/Ut/7EE/kV3Q7OWdh2zJKpr7I09yWKy9WLDzb83In973ASXPXiVI/E05kW2Hmm7kIssx37cT38jBNvFyfkBWpbTtpGCfCtbwoNoPUjszc8W3LjFLbT1M78LzItlMvyIMwsKwotwNTLv6EpmfZoYWc5N4X3C+58BsDxA85VfCuHsHPBOKHTLj2I6xNbyDrKA3HkrblerYpbC/PROKJJM6jXDaiJHbDLE0lUFmcB35qpontCGFbkRcpsRPT96M8dvJXK/TMLM78JHB9J5Arsq6IEjcVwjEj38ns1EniNLJi2w4SJ7OiMBeZyEInTSIriDzTd/x+9ACy95U3S5PQid3YiYM4jU1PzreHcv4+lbyaoewdpisyJ8qksm0/tuzYyn1XmEEo1S7stMqfCNI8tVKp1dS2fMuVUKqeYUq589j2Zd90bNvN88jzTSuK0iyIPcdP48yM7TTJBLe8phWbsZNJpnw7F64rUifMXT+z3NgNfCsIE9lMcrlw7gjfsrJEpEEeOY4TulmeB/34E6GSLIxT4SVhmknhvSRx7ECqU5huIqLAzxLPD30nCezYtRJHqtbxUlPiZ4nU4pB3REGrXEwtV7L31do7ae13ae09tPZ+RXt/WafLegA1O+o9gHh8JmH5tHQsDiyOM0pAyuRBXfhr5dwM6j9CQY/2dBDX1glnxUj1QMI59Bk4GRsd7ekYiMC2LN9W9wWpXABP5XjZstLYMRPp8CzpyUWYO5ZjJ2kSS5qRyM08SsI8eI2Wzu9MToYV8WrGXpf5mcBOehBQXi4MDxqAbl0MDyKsh0PLPWMQuevSPZiwEa90qAdT/8iEnkYcAez3+xNPhEPLPBIo83TCOn6iZrKRDYlHV9Qdn13Nwc8qjoeUgJSGoi5U5+DVTdxz8IcAaR06dNC6moM/lPjn4DccOg4d5+BnMenHrFmazMpmdcF3N3Pwh3EyrIij5+APwylQHA6UlwvDwwk/B384YT09Wu5DCrnRc/BIfb8biKHunBXdplffN6Lei/xHFMcjS0BKANWFauQ/kvgj/5FAWkcRT+Q/ivgj/0aEi/xHMOnHrFmajPxHEE/kP5qTYUUcHfmPxilQHEPtjvwKw2MIH/mPoXZH/iMLudGRH6nvY4kn8iu6TUf+sdR7kf+44ji7BKQEUF2oRv7ZxB/5ZwNpvYd4Iv97iD/yjyVc5D+OST9mzdJk5D+OeCL/8ZwMK+LoyH88ToEionZHfoVhRPjIH1G7I//sQm505EfqOyaeyK/ocu+70ydk6+57Qk5yJ8STgaDx2wiIH3KqIO0R/MYC8UMmXBlhbfr1fXelvK/vu/tn3nenYkC5jy7R2kdq7VRrz9baWdHOZT1B1hOp2VHvicTjMwnLZ599dycVx5NLQMrkQV2o7rs7mfj33ekg1t13dxLhHPrJOBkbHe3pGCD33Z3CybAiXs3Y6zJ/CrCTngqUlwvDUwm/7+5Uwno4tNwnDyJ3XbqnETbilQ71NOLfd7cBsN/nxBPh0DKPAsp8ApPM6MA5gqnP1KX1XvrHBE6zXhFIvnV+T+dk+HQGumcQb7Az65VVcp+hAQyiy2qsI4nH2dWl9T7qTWNF8q3zeyYnw2cy0D2L2m2sSu6zNIBBdBuLrGa9AnWm7ydspx9V6FvRLedURmrtM2i1QW+gnR+ltcspgrNlPUfWc7V7yrmegWjP0Gh3uucDsp4n6/mF7BwB7yzCjyIuIGx/R/PHJfcHgbohraBHDTOAtD4Elrnb9ctONJV9IvWibPIChr4zh7A2g8bxHDCO5zHheCHxxFq0DZ4MpHVRy21QxVDg49xC+Zw5DH3nYmq3DY5iwPFCBhwvaTmOKu8CLnOIi+i1/SdoHNdrOY4jGXC8hAHH9YE4Kt6qXwmZSN1/geRSWS+T9XJZP0yDf4HEWAvaV8j6EVk/KuuV1PwXSC4lnhhM3fHZ1a7oq4rj1SUg5dKFulDdFa1uurjCFDpBuBpI62NDB62rXdEfI/5d0ZcOHYeOu6KvYtKPWbM0uU5+VRd8d7Mrei4nw4p4t9Gr0/+di1OguAYoLxeG1xB+V/Q1hPX0aLmvLuTutu90oovU98cJm52UzlnRVc65ych/BfVe5L+2OM4rASkBVBeqkX8e8Uf+eUBa1xFP5L+O+CP/FYSL/Ncy6cesWZqM/NcST+S/npNhRRwd+a/HKVDcQO2O/ArDGwgf+W+gdkf+eYXc6MiP1PeNxBP5Fd1Ozrnu8yj6sKzu8yjIoe5NxJOBoPG7AogfMmGYD+6Tau5/hIbj32l7sZknVh47jpRIyps6YSbxCR3bTAIrsTNTpGFk514am6mVWU4cZH7i5kEqgjBM+j3vYUZ5nghLGrCU1hJ2Zgs3StJQeHEkbN/xnDhy1C5fy0rTXOLjp6GVmpYv4ZB/zP58S77qoROp4yh0JCuB4+VpYKW+J+Isk5xnYZx5pmWL0PXzOIsT1/F8J3AtJ7StOKvyZ3lZbArf8t3ACmVvcBzhRZElpJqtKI4tV3a6TF5NfCmsmTi57GFJIBz1lFTiuyzPL+nzlsqmy/nJm7T2PK09v2gvkPVmWW+hZkcrtxCPryAsn32eY7m1OC4sASmdvrpQfY5lIfE/x6KDWPc5llsJ58gW4mRsNEvXMUA+x7KIk2FFvJpp1WV+EbCTLgbKy4XhYsI/x7KYsB4OLffCQeSuS/c2wka20qHeRvzPsYwD9vsFxBPh0DJvCpT5ZsI6fqJmspFJxKMr6o7PruZOlxTHpSUgpaGoC9W5U3UT99zpUiCt24cOWldzp7cT/9zppKHj0HHudAmTfsyapcmsbEkXfHczd3oHJ8OKOHru9A6cAsWdQHm5MLyT8HOndxLW06PlXlrIjZ47Rer7E0AMdees6Da9aroZ9V7kv6s4LisBKQFUF6qRfxnxR/5lQFp3E0/kv5v4I/9mhIv8dzHpx6xZmoz8dxFP5L+Hk2FFHB3578EpUNxL7Y78CsN7CR/576V2R/5lhdzoyI/U9yeJJ/IrutyrpvqwrO6qH3Koex/xZCBo/DYD4odMGO4H98nXV00LeuvYqqmy6XJ19D6tvUxr31+0H5D1U7I+SM2OVh4kHl9BWD77rJp+ujguLwEpnb66UF01XU78q6Y6iHVXTT9NOEe2HCdjo1m6jgFy1fQznAwr4uhV088AO+lDQHm5MHyI8KumDxHWw6HlXj6I3HXpfpawka10qJ8l/lXT8cB+/wDxRDi0zBOAMn+KsI6fqJlsxCAeXVF3fHY1d/pwcXykBKQ0FHWhOneqbuKeO30ESOtzQwetq7nTzxH/3KkxdBw6zp0+zKQfs2ZpMit7uAu+u5k7/Twnw4o4eu708zgFikeB8nJh+Cjh504fJaynR8v9SCE3eu4Uqe8vADHUnbOi2/Sq6WTqvcj/WHFcUQJSAqguVCP/CuKP/CuAtL5IPJH/i8Qf+ScTLvI/xqQfs2ZpMvI/RjyR/0ucDCvi6Mj/JZwCxePU7sivMHyc8JH/cWp35F9RyI2O/Eh9/wvxRH5Fl3vVVB+W1V31Qw51v0w8GQgav8lA/JAJwxPgPvn6qmlBbx1bNVU2Xa6Ofllrr9DaTxTtlbI+KetXqNnRyleIx1cQls8+q6ZfLY5PlYCUTl9dqK6aPkX8q6Y6iHVXTb9KOEf2FE7GRrN0HQPkqunXOBlWxNGrpl8DdtKvA+XlwvDrhF81/TphPRxa7qcGkbsu3W8QNrKVDvUb1D8yoR3qOCAO44G0/pX+MQ7VrFcEkm+d329yMvxNBrpPE68TNOuVVXI/rQEMosv6eZ5NgZhOANL6FvWmsSL51vn9NifD32ag+wy121iV3M9oAIPoshor8i0OSGf6HcJ2+vJ7V4puOdbeVGs/TasNerx2foLWLjfcflfW78n6bPF7SXvcILQXarQ73fN9WX8g6w8L2TkC3jOEzy5/RNj+juaPS+5/A+qGtIJeQF0IpPXvYJm7XY/oRFPZJ1IvyiZ/xNB3fkxYm0Hj+D0wjj9gwvEnxBNr0Ta4HEjrpy23QRVDga+2E8rn/Jih7/yM2m2DExhw/AkDjj+n3oj/aP0gc95fMGNo1iur+s5PGXTzXMvlVnp5jkHu/2i53MrvLGeQ+5ctl3sck9zfMdott7LtnzHI/V2w3GVZD8znSiCt/wTqBdhvBFIXTU6CAvHsMwn6K06Gf8VA99fATsol9681gEF0WXhVE3Acjv57PeDof84g97M94uifBNL6L6BegP1GPNujjh6IZx9H/xtOhn/DQPd5arejV3I/rwEMortGwzfrFWjw/G/658/wdF1UVx7r4vcC/fM7Tn11UPWXcrXvBa39a1rtXFdq55/U2uWm1d/K+jtZf099C1o3L64jfZtjRueXhF+lB84UiV8C5X2JeGzlxUFs5SXNVjrd8z+y/kHW/y344xiIPc/Qh/5I7e7jXHL/Cagb0gp6Fe8lIK0/g2VGr26oeIPUi7LJPzL0nZcJazNoHH8HxvEPTDi+AsaRywafAtL6v5bboMoJgXFWKJ/zMkPf+Qu12wafZMDxFQYc/9pyHJXtIccHyv7+QngfsTGQ1qtAnTQ5mYbkW+f3b5wM/42BLhntnkx7VSdK7XcAyMkb5QD+SngHsAmQltGjs+lIvnV+hxmMDCviaLrDW+4AlNzDmRxAWdCzhBsD5X8RyNd6PWqs6zEZ6/oGI8PrMxjriJYbq5J7RI8Z6yZA+V8A8jWyR411JJOxbmAwMrwBg7GOarmxKrlHMRkrxzBluIGfUxjd8g1JIwodoeUe0/L1QqUXxSN6iAbUtxgDtG+Fn9p0p78Va0davXY3XGtvo7WnFu3y7zaUJzeSdaysGxurz5NGF6mnTXB42gNhoOQpZd3EGBoG4+TJTWUdL+uEBjCYiMPA6YTBxCFiMEme3EzWN8j6xgEwQK/DjwbiiZyfHGc0k4Sa9YoYQzwJbV1ak5jwQ/v14UCZ3wSMEQPZs3qbZ2m3bxqiPW8uT75Z1rfI+tbCntf09kM0vsOAtCYST5+i7mTu6r3vWxRBY8tyFFW+5EtdmFM5p266uINC6nbSLYHJx9u66PDdvPf9bQPggN64ytUx675DfguDR9dmzdLk2ym36ILvbt4hv5XByPBWBv4d8lsBI8rWzLMKCAy3XovZlE7/d+uWj1i3LOTutu90oovU9zbgqbnS0W8zBEdf9x3ow4C0dEdf933qyEC8LVg/r79PvaC3jr1PfUttVLGt1h7oPeuT5S/bybq90ez71LdnGlkSls8+71PfoQBhSnUUoC5U36c+xeifZaGnDbYHOJ/yfeo7AB3ZlB7NWHUMkO9Tn2owMjzVwL9PfSowY92x5RmrwnDHATLWuhju2PKMdcogctel+3amLPPtBv/71JHvQJ8M7Pfv+Ac5VLNeEe8A94WyvNNgZPidBp6uyewEzXplldw6wiC6rIsmyHegbwfUj+hRYxVMxmoZjAxbDMZqt9xYldx2jxnreGqnM3WYszSzXlm1Y8U08AtIo4EYusDRAheGU1qOoQfEUOFXvjHAMQZ+Z79rrA4sk7V7ttPaXnGPL38EsoaVKNRmPKcx4TnYNxCmaXh2umcn+WNnWXcp8ORINm0DP7LbtQd85a4Mcu/W8pF8KXe3a08dikDa4+5gDNGyKh8H5FEoG9+NoS/u0XIcAzCOOzPhuGcP+LIpDHLv1QO+jEPuvcE5KoevBdr2Kn82jQHHfVrufxSOQNte5c84cNy35TiqHBboK4Syv30YcHxXy3GcwIDjvgw47gee/OulvSeK39EDzSO2cN+Izqu+52OgvR2qvUJrP1G095e/TJf1AKPZPR8HgG21WkC0++z5OLAAYUY5uC+XI9WF6p6PGQb/no8DAIOycs/HgcAB3gygcpvc86FjgNzzMdNgZHimgd/zMRMYpQ4CdiwuDA8y8Hs+Dmr56GrGIHLXpXswOHsoHerBWj/nmCWd1vJZs1ktn6WY0gMYHgLum51WVmYZnVdWDinuOVT+OEzWw4vfO60yjDY6rzKU97xb/jhC1iMNPvvhWGU4quV9XvX3oxjkPrrlsaOUG23r04C2fkzLZwOUvQN5FMrGj2boi8e2HMfDwDgewYTjcT0Sv9Fyz265L+OS+z3APslhNyo3ONTA+u5jGXA8vuX+Z3SRtyFxPI4Bx6jldljmkGj9IHcIxmAMyzIMjOUUoMwJ2I+h45Ya+8xmsJc/tTxeq/hyPIPcf2bq4+gPVO4P7OMpsI8D+41A6qLJxweAePaZSM8MRoYzA083B3ZSLrlzDWEQXRZe1cQWh6N/uQccfcQg9ys94uinA23oBKBzBvYb8UqPOvoTmBz9iQYjwycyOPqTWu7oldwnMTn6sqBf6IYMnievAxmergv0q/FPWQccJ4fdTSsSrDavip7aAxjOaDmGp4EDYbn6q/xWuZp7itY+1Vgd5PfXzk/X2qcV97xX/jhd1jMKxaD1o2bFEoYE9X094hvPXEdiC4ddv6/ldn0Wk12fOYhdn6XZdad73i9/nC3rOUx2nRc5I9quz+2Bfnkug9wfYJYbsavjXKPduzrOA2OIllXFWiCPQtn4Bxj64vktx/F0MI5nM+F4QY/EWLTcH+wBX8Yh94eAfZLDblTu814D23/OZ8BxTsv9z+hizITE8QIGHC/skbE7Wu6LesD/cMh9ccv9j5qLAMYGofztHAYcL2m5/5nOgOOFDDhe2nIc1Rga6CuEsr9LGHC8rOU4nsKA46UMOF4Onq9Z05cYh/rFrg/Lk1fI+hFZP2q8dn4g2h82uv/C4ZXy5FWyXi3rx4ZIe6hfDpwrT14j68dlvdYY/EtjHLkX8F0Oq3KQywx8bnMl2GarZYi0u/p62bwChOsM6vu8urowp3JO3XRxhamqsusa7HXAyaHru1BIN18vu17DAd2Jys6OdoRjhrV/YHAZg9wbDuMxyvXB8l859H7f8Qtz8wweezTrFQHsgwKp1ybfKTGvCzy7+fLdDQYjw4p4t1G90/+9AdixbgR2eC4Mb1yLjKPT/72x5bMe1xVyd9t3OtFF6vsm8AihTBJuKpKEpjJk4Fu6VgXjyxky5Lk9mCHPL0BYUM2Q5w+QIS9oIENeAOz8NzNlyDczZ8j7MWSKY3sgQ76cQe6NeyRDngvMkOcbPPZo1isC2AcFUq9NZsjzmTLkWwxGhm9hyJBvAXasW1ueISsMb2XIkG9teYa8oJAbnSEj9b2QKUNeuIYMmQaxVbNeEZv3YAa6qABhcTUDXTRABrq4gQx0MbBz3caUgd42AA7o961uDsxIFhk8+jFrliYj/yKmyL/EYGR4CUPkXwKM/EtbHvkVhksZIv/Slkf+xYXc6MiP1PftTJH/9gGcc3W4KGxbRsnUF3ma264fWrHwbM/Lndz3AifNXSdK/Uw4kW2FmW/mIsgy37UT38vDNPFyfUFFpLbtpGGcCNfyotgMUjsyc8e3LTNKbT9N7cDzIttOvSAPwsCyotwOTNf3Q9Oz7NBCLkreYeBk1BdU6tJqaqGsLp9zgXpFTqXdCdTrWKBeuaZ3hoP1ujlQr8gE9RNgH6i+fjFKw7GkbbmebQrbyzOReCKJ8yiXjSiJ3TBLUwlUpr71kJppYjtC2FbkRUrsxPT9KI+dvPpFCTOLMz8JXN8JQi9zRZS4qRCOGflOZqdOEqeRFdt2kDiZFYW5yEQWOmkSWUHkmb7j96MHkL2vvFmahE7sxk4cxGlseqYIQjf1U8mrGcreYboic6JMKtv2Y8uOrdx3hRmEUu3CTvt97SNI89RKpVZT2/ItV0KpeoYp5c5j25d907FtN88jzzetKEqzIPYcP40zM7bTJBPc8ppWbMZOJpny7Vy4rkidMHf9zHJjN/CtIExkM8nd3HOEb1lZItIgjxzHCd0sz4N+/IlQSRbGqfCSMM2k8F6SOHYg1SnMVR8n8bPE80PfSQI7dq3Ekap1vNSU+FkitTjkLb/qotoqZpY7ye7Q2gu09p1ae7HW/kTRvksel8l6t9F5F5u+c21Nu9jukSfvlfWTst5nrD5PGl0dl7r+435gLt8Jg/uNoWHwgDz5KVkflPXTxtB2CQ6G77YV2svlyc/I+pCsn20A34dx+FqdMHh4iPg+Ik9+TtbPy/qohm8vffmoD381Sz9f2MKvJ6HlXW8gPdcr8Bi1Jt/7BXl8TNYVBvUp3Y5XO8n0BsL5Aq7ZXbTMbwTKfFePyPwmoMzLmGRGv6puGJDWRKAuNgfydQ+TLtBvZTGA+L0ZyNcDDeFn1iviLUCZlwPH54+0fJ5X0eP4nsB48LzOCDB/yvch37wzrMARRW8imL+JYP4mgfmbVPCH9gtvBfYZ4BNUAm0f6NzAAOt3MwZ6yP48man/bQHUydwW97+yoPPyLYH4faFHxiJvA8r8WENjEbNeEVsRj59GPpjY1of90LrYmnh8FnILfJu2levzaRM0vahYovLWkbR6XW20rGNk3VDWjWQdK+vGsm4i6zh6bX53fEFH5WwqL9qM+s75Dit+X7+go4qap1LzNmoeQ42f1RhQjYlU/qNi0JayKr+i7Gzr4n+XxS2O+eLvv/xbZ/oC7RJ5xfG2PV+870/R+4/Vr2XFccpV40eueOmJ3fRreXG8/GsrX3jm+cWH6NfOL44nPv3s+I/cEL9Rv3ZBcXzmolnnbfjD4yfp124rjiuWjTvphbtXvqRfW1Icxz8388LDHt/lh/q1J4rj5r/41oPPzfr9Uv3ayjVcm1oMimZ+/JwTnzx78T76NVFcm3+a/5aVO+x7nX7NKq49Gf1x40W73rRXeb6MExsUx3KddXRxLPeg7F78btYrVkl/DA99cyT1L6O19pjKtVL+9Qb4O2OQ34dVjmu6t3peP7fRANdKmuOLo85vKceoynGiRheIpSjpT+ChP6CuJmrtCRU5dbx3B/FQ0itz7PWpfxlWuVbeW7UZA8+fqPIyfID/VZayz+j+vsTz/wHiyI8fPLkBAA==","debug_symbols":"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","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"61":{"source":"use dep::std;\nuse dep::std::field::bn254::{assert_gt, assert_lt, lt};\nuse dep::poseidon::poseidon2::Poseidon2;\nuse dep::poseidon_ctr_encryption::{poseidon_ctr_encrypt, poseidon_ctr_decrypt};\nuse dep::pedersen_commitments::pedersen_commitments::{\n    pedersen_commitment_positive,\n    pedersen_commitment_negative,\n    pedersen_commitment_counter,\n    add_commitments, \n    add_multiple_commitments,\n    pedersen_commitment_non_hiding\n};\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint;\nmod test;\n// === NYDUS-DEPOSIT CIRCUIT ===\n\n\n\nglobal VIEW_STRING: Field = 0x76696577696e675f6b6579 as Field;\n\n\n// === MAIN FUNCTION ===\n\nfn main(\n    user_key: Field,\n    token_address: pub Field,\n    amount: pub Field,                    // Deposit amount (always positive)\n    previous_nonce: Field,\n    \n    main_c_tot: pub [Field; 2],               // Total commitment from previous operation\n    main_c_inner: [Field; 2],             // Inner commitment (deposits)\n    main_c_outer: [Field; 2],             // Outer commitment (rest/change)\n    main_c_inner_point: [Field; 2],       // Opening values for inner commitment\n    main_c_outer_point: [Field; 3],       // Opening values for outer commitment\n\n    personal_c_tot: [Field; 2],           // Total commitment from previous operation\n    personal_c_inner: [Field; 2],         // Inner commitment (deposits)\n    personal_c_outer: [Field; 2],         // Outer commitment (rest/change)\n    personal_c_inner_m: Field,            // Inner amount\n    personal_c_outer_m: Field,            // Outer amount  \n    personal_c_outer_r: Field,            // Total number of tokens in the commitment\n\n) -> pub (Field, [Field; 2], [Field; 5], [Field; 2], [Field; 2]) {\n    \n    // === SETUP ===\n    let user_key_hash = Poseidon2::hash([user_key], 1);\n    let view_key = Poseidon2::hash([VIEW_STRING, user_key_hash], 2);\n    let previous_nonce_commitment = Poseidon2::hash([user_key_hash, previous_nonce as Field], 2);\n    let current_balance = personal_c_inner_m;\n    \n    // === VERIFICATION ===\n    verify_main_commitments(\n        main_c_tot,\n        main_c_inner,\n        main_c_outer,\n        main_c_inner_point,\n        main_c_outer_point,\n        previous_nonce_commitment,\n        view_key,\n        previous_nonce\n    );\n    \n    let nullifier_was_initialized = verify_personal_commitments(\n        personal_c_tot,\n        personal_c_inner,\n        personal_c_outer,\n        personal_c_inner_m,\n        personal_c_outer_m,\n        personal_c_outer_r,\n        token_address,\n        user_key_hash,\n        main_c_inner_point,\n        view_key,\n        previous_nonce\n    );\n    \n    // === PROCESSING ===\n    let nonce = previous_nonce + 1 as Field;\n    let new_nonce_commitment = Poseidon2::hash([user_key_hash, nonce as Field], 2);\n    \n    let (new_main_commitment, enc_x, enc_y) = create_new_commitments(\n        current_balance,\n        amount,\n        personal_c_outer,\n        personal_c_outer_r,\n        token_address,\n        user_key_hash,\n        new_nonce_commitment,\n        nullifier_was_initialized,\n        view_key,\n        nonce\n    );\n    \n    let encrypted_note = encrypt_operation_details(\n        current_balance,\n        token_address,\n        nonce,\n        view_key,\n        personal_c_outer_m,\n        personal_c_outer_r,\n        amount,\n        nullifier_was_initialized,\n        user_key_hash\n    );\n   \n    let nonce_discovery_entry = pedersen_commitment_non_hiding(1, new_nonce_commitment);\n    \n    // === RETURN VALUES ===\n    (   \n        new_nonce_commitment,\n        [new_main_commitment.x, new_main_commitment.y],\n        encrypted_note,\n        [nonce_discovery_entry.x, nonce_discovery_entry.y],\n        [enc_x, enc_y]\n    )\n}\n\n\n// === HELPER FUNCTIONS ===\n\n/// Verify main stack commitments using opening values\nfn verify_main_commitments(\n    main_c_tot: [Field; 2],\n    main_c_inner: [Field; 2], \n    main_c_outer: [Field; 2],\n    main_c_inner_point: [Field; 2],\n    main_c_outer_point: [Field; 3],\n    previous_nonce_commitment: Field,\n    view_key: Field,\n    previous_nonce: Field\n) {\n    // Verify that main_c_inner was created using the encrypted coordinates in main_c_inner_point\n    let reconstructed_main_c_inner = pedersen_commitment_positive(main_c_inner_point[0], main_c_inner_point[1], previous_nonce_commitment);\n    assert(reconstructed_main_c_inner.x == main_c_inner[0], \"Main inner commitment x verification failed\");\n    assert(reconstructed_main_c_inner.y == main_c_inner[1], \"Main inner commitment y verification failed\");\n\n    // Verify outer commitment\n    let reconstructed_main_c_outer = pedersen_commitment_positive(main_c_outer_point[0], main_c_outer_point[1], main_c_outer_point[2]);\n    assert(reconstructed_main_c_outer.x == main_c_outer[0], \"Main outer commitment x verification failed\");\n    assert(reconstructed_main_c_outer.y == main_c_outer[1], \"Main outer commitment y verification failed\");\n\n    // Verify total commitment\n    let main_c_tot_commitment = add_commitments(reconstructed_main_c_inner, reconstructed_main_c_outer);\n    assert(main_c_tot_commitment.x == main_c_tot[0], \"Main total commitment x verification failed\");\n    assert(main_c_tot_commitment.y == main_c_tot[1], \"Main total commitment y verification failed\");\n}\n\n/// Verify personal commitments and determine if nullifier was initialized\nfn verify_personal_commitments(\n    personal_c_tot: [Field; 2],\n    personal_c_inner: [Field; 2],\n    personal_c_outer: [Field; 2],\n    personal_c_inner_m: Field,\n    personal_c_outer_m: Field,\n    personal_c_outer_r: Field,\n    token_address: Field,\n    user_key_hash: Field,\n    main_c_inner_point: [Field; 2],\n    view_key: Field,\n    previous_nonce: Field\n) -> bool {\n    // Hash inner commitment parameters\n    let personal_c_inner_m_hash = Poseidon2::hash([personal_c_inner_m, user_key_hash], 2);\n    let personal_c_inner_token_address_hash = Poseidon2::hash([token_address, user_key_hash], 2);\n    \n    // Verify inner commitment\n    let inner_commitment = pedersen_commitment_non_hiding(personal_c_inner_m_hash, personal_c_inner_token_address_hash);\n    assert(inner_commitment.x == personal_c_inner[0], \"Inner commitment x verification failed\");\n    assert(inner_commitment.y == personal_c_inner[1], \"Inner commitment y verification failed\");\n\n    // Verify outer commitment\n    let outer_commitment = pedersen_commitment_non_hiding(personal_c_outer_m, personal_c_outer_r);\n    assert(outer_commitment.x == personal_c_outer[0], \"Outer commitment verification failed\");\n    assert(outer_commitment.y == personal_c_outer[1], \"Outer commitment verification failed\");\n    \n    // Check if nullifier was already initialized\n    let initializer = pedersen_commitment_non_hiding(token_address, user_key_hash);\n    \n    // Check both cases: with and without initializer (for first deposit after entry)\n    let sum_with_initializer = add_multiple_commitments([\n        inner_commitment,\n        outer_commitment,\n        initializer\n    ]);\n    \n    let sum_without_initializer = add_multiple_commitments([\n        inner_commitment,\n        outer_commitment\n    ]);\n    \n    let with_initializer_matches = (sum_with_initializer.x == personal_c_tot[0]) & (sum_with_initializer.y == personal_c_tot[1]);\n    let without_initializer_matches = (sum_without_initializer.x == personal_c_tot[0]) & (sum_without_initializer.y == personal_c_tot[1]);\n    \n    assert(with_initializer_matches | without_initializer_matches, \"Total commitment verification failed\");\n    \n    // Decrypt the encrypted coordinates from main_c_inner_point and verify they match personal_c_tot\n    let previous_encryption_key = Poseidon2::hash([view_key, previous_nonce], 2);\n    let decrypted_x = poseidon_ctr_decrypt(main_c_inner_point[0], previous_encryption_key, 3);\n    let decrypted_y = poseidon_ctr_decrypt(main_c_inner_point[1], previous_encryption_key, 4);\n    \n    // Verify decrypted coordinates match personal_c_tot\n    assert(decrypted_x == personal_c_tot[0], \"Decrypted x coordinate doesn't match personal_c_tot\");\n    assert(decrypted_y == personal_c_tot[1], \"Decrypted y coordinate doesn't match personal_c_tot\");\n    \n    with_initializer_matches\n}\n\n/// Create new commitments after deposit\nfn create_new_commitments(\n    current_balance: Field,\n    amount: Field,\n    personal_c_outer: [Field; 2],\n    personal_c_outer_r: Field,\n    token_address: Field,\n    user_key_hash: Field,\n    new_nonce_commitment: Field,\n    nullifier_was_initialized: bool,\n    view_key: Field,\n    nonce: Field\n) -> (EmbeddedCurvePoint, Field, Field) {\n    let new_balance = current_balance + amount;\n    let new_balance_commitment = pedersen_commitment_non_hiding(new_balance, token_address);\n    \n    let personal_c_outer_commitment = EmbeddedCurvePoint { x: personal_c_outer[0], y: personal_c_outer[1], is_infinite: false };\n    \n    let new_personal_c_tot_commitment = if nullifier_was_initialized {\n        add_multiple_commitments([\n            personal_c_outer_commitment,\n            new_balance_commitment\n        ])\n    } else {\n        let initializer = pedersen_commitment_non_hiding(token_address, user_key_hash);\n        add_multiple_commitments([\n            personal_c_outer_commitment,\n            new_balance_commitment,\n            initializer\n        ])\n    };\n    \n    let encryption_key = Poseidon2::hash([view_key, nonce], 2);\n    let enc_x = poseidon_ctr_encrypt(new_personal_c_tot_commitment.x, encryption_key, 3);\n    let enc_y = poseidon_ctr_encrypt(new_personal_c_tot_commitment.y, encryption_key, 4);\n    \n    let new_main_commitment = pedersen_commitment_positive(\n        enc_x,\n        enc_y,\n        new_nonce_commitment\n    );\n    \n    // Return the new main commitment and encrypted coordinates\n    (new_main_commitment, enc_x, enc_y)\n}\n\n/// Encrypt operation details for privacy\nfn encrypt_operation_details(\n    current_balance: Field,\n    token_address: Field,\n    nonce: Field,\n    view_key: Field,\n    personal_c_outer_m: Field,\n    personal_c_outer_r: Field,\n    amount: Field,\n    nullifier_was_initialized: bool,\n    user_key_hash: Field\n) -> [Field; 5] {\n    let encryption_key = Poseidon2::hash([view_key, nonce], 2);\n\n    let new_balance = current_balance + amount;\n    \n    // Calculate opening values for new personal_c_tot commitment\n    // Components: outer (m=personal_c_outer_m, r=personal_c_outer_r) + new_balance (m=new_balance, r=token_address) + optionally initializer (m=token_address, r=user_key_hash)\n    let personal_c_tot_m = if nullifier_was_initialized {\n        personal_c_outer_m + new_balance\n    } else {\n        personal_c_outer_m + new_balance + token_address\n    };\n    \n    let personal_c_tot_r = if nullifier_was_initialized {\n        personal_c_outer_r + token_address\n    } else {\n        personal_c_outer_r + token_address + user_key_hash\n    };\n\n    let encrypted_amount = poseidon_ctr_encrypt(new_balance, encryption_key, 0);\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\n    \n    // Self-reference check: encrypt hash of encryption_key for decryption verification\n    let view_key_hash = Poseidon2::hash([encryption_key], 1);\n    let encrypted_reference = poseidon_ctr_encrypt(view_key_hash, encryption_key, 2);\n    \n    // Encrypt opening values for personal_c_tot\n    let encrypted_personal_c_tot_m = poseidon_ctr_encrypt(personal_c_tot_m, encryption_key, 3);\n    let encrypted_personal_c_tot_r = poseidon_ctr_encrypt(personal_c_tot_r, encryption_key, 4);\n    \n    [encrypted_amount, encrypted_token_address, encrypted_reference, encrypted_personal_c_tot_m, encrypted_personal_c_tot_r]\n}\n\n\n","path":"/home/drone/projects/ethrome25/circuits/main/nydus-deposit/src/main.nr"},"71":{"source":"use dep::std;\nuse dep::std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\nglobal NULLIFIER_DOMAIN_SEPARATOR: Field \n    = 0x100000000000000000000000000000000000000000000000000000000000000;\n\nglobal COUNTER_DOMAIN_SEPARATOR: Field \n    = 0x200000000000000000000000000000000000000000000000000000000000000;\n\n\npub fn pedersen_commitment_token(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // Use derive_generators to get different generators for G and H\n    let generators: [EmbeddedCurvePoint; 3] =\n        std::hash::derive_generators(\"PEDERSEN_COMMITMENT\".as_bytes(), 0);\n    \n    let G = generators[0];  // First generator for amount\n    let H = generators[1];  // Second generator for blinding factor\n    let D = generators[2];  // Third generator for domain separation\n     // Create scalars for multi_scalar_mul\n    let mut scalars = [EmbeddedCurveScalar { lo: 0, hi: 0 }; 3];\n    scalars[0] = from_field(m);\n    scalars[1] = from_field(r);\n    scalars[2] = from_field(token_address);\n    \n    // Create points for multi_scalar_mul: [G, H, D]\n    let mut points = [EmbeddedCurvePoint::point_at_infinity(); 3];\n    points[0] = G;\n    points[1] = H;\n    points[2] = D;  \n    \n    // Compute commitment: m*G + r*H + token_address*D\n    multi_scalar_mul(points, scalars)\n}\n\npub fn pedersen_commitment_non_hiding(m: Field, token_address: Field) -> EmbeddedCurvePoint {\n    let generators: [EmbeddedCurvePoint; 3] =\n        std::hash::derive_generators(\"PEDERSEN_COMMITMENT_PERSONAL\".as_bytes(), 0);\n    \n    let G = generators[0];  // \n    let D = generators[1];  // \n     // Create scalars for multi_scalar_mul\n    let mut scalars = [EmbeddedCurveScalar { lo: 0, hi: 0 }; 2];\n    scalars[0] = from_field(m);\n    scalars[1] = from_field(token_address);\n    \n    // Create points for multi_scalar_mul: [G, H, D]\n    let mut points = [EmbeddedCurvePoint::point_at_infinity(); 2];\n    points[0] = G;\n    points[1] = D;\n    \n    // Compute commitment: m*G + r*H + token_address*D\n    multi_scalar_mul(points, scalars)\n}\n\n\n\npub fn to_negative_domain(token_address: Field) -> Field {\n    token_address + NULLIFIER_DOMAIN_SEPARATOR\n}\n\npub fn to_nullifier_domain(token_address: Field) -> Field {\n    token_address + NULLIFIER_DOMAIN_SEPARATOR\n}\n\n\n\n// === DOMAIN SEPARATION FOR negative/positive ===\n// Creates distinct commitment spaces for the same token\n\npub fn pedersen_commitment_negative(m: Field, r: Field, token_address: Field, mult: Field) -> EmbeddedCurvePoint {\n    // negative space: add 1 to the most significant bit\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    // becomes 0x10000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    let negative_domain = token_address + NULLIFIER_DOMAIN_SEPARATOR;\n    pedersen_commitment_token(m, r, negative_domain * mult)\n}\n\npub fn pedersen_commitment_counter(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // negative space: add 1 to the most significant bit\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    // becomes 0x20000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    let counter_domain = token_address + COUNTER_DOMAIN_SEPARATOR;\n    pedersen_commitment_token(m, r, counter_domain)\n}\n\n\npub fn pedersen_commitment_positive(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // positive space: token_address (original)\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    pedersen_commitment_token(m, r, token_address)\n}\n\n// === COMMITMENT VERIFICATION ===\n\npub fn verify_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field) -> bool {\n    let computed_commitment = pedersen_commitment_token(m, r, token_address);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\npub fn verify_negative_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field, mult: Field) -> bool {\n    let computed_commitment = pedersen_commitment_negative(m, r, token_address, mult);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\npub fn verify_positive_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field) -> bool {\n    let computed_commitment = pedersen_commitment_positive(m, r, token_address);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\n// === COMMITMENT ARITHMETIC ===\n\npub fn add_commitments(c1: EmbeddedCurvePoint, c2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    c1 + c2\n}\n\npub fn add_multiple_commitments(commitments: [EmbeddedCurvePoint]) -> EmbeddedCurvePoint {\n    let mut result = EmbeddedCurvePoint::point_at_infinity();\n    \n    for i in 0..commitments.len() {\n        if i == 0 {\n            result = commitments[i];\n        } else {\n            result = result + commitments[i];\n        }\n    }\n    \n    result\n}\n\npub fn subtract_commitments(c1: EmbeddedCurvePoint, c2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // c1 - c2 = c1 + (-c2)\n    let neg_c2 = -c2;\n    c1 + neg_c2\n}\n\n\n// === BALANCE VERIFICATION ===\n// Proves that negative commitments >= positive commitments\n\npub fn verify_balance_proof(\n    negative_commitment: EmbeddedCurvePoint,\n    positive_commitment: EmbeddedCurvePoint,\n    total_commitment: EmbeddedCurvePoint,\n    negative_m: Field,\n    negative_r: Field,\n    positive_m: Field,\n    positive_r: Field,\n    token_address: Field\n) -> bool {\n    // Verify commitment openings\n    let negative_valid = verify_negative_commitment_opening(negative_commitment, negative_m, negative_r, token_address, 1);\n    let positive_valid = verify_positive_commitment_opening(positive_commitment, positive_m, positive_r, token_address);\n    \n    // Verify arithmetic: negative + positive = total\n    let sum_commitment = add_commitments(negative_commitment, positive_commitment);\n    let x_equal = sum_commitment.x == total_commitment.x;\n    let y_equal = sum_commitment.y == total_commitment.y;\n    let arithmetic_valid = x_equal & y_equal;\n    \n    // Verify sufficient balance: negative_m >= positive_m\n    let balance_valid = (negative_m as u128) >= (positive_m as u128);\n    \n    ((negative_valid as u1) & (positive_valid as u1) & (arithmetic_valid as u1) & (balance_valid as u1)) as bool\n}\n\n// === UTILITY FUNCTIONS ===\n\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\nfn from_field(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = compute_decomposition(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/pedersen-commitments/src/pedersen_commitments.nr"},"79":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon/src/poseidon2.nr"},"81":{"source":"use dep::std;\r\nuse dep::poseidon::poseidon2::Poseidon2;\r\n\r\n/// Poseidon CTR Mode Encryption Library\r\n/// \r\n/// This library provides Poseidon-based encryption in CTR mode for field elements.\r\n/// It includes functions for encrypting individual fields and batch encryption.\r\n\r\n/// Generate a keystream using Poseidon with key and nonce\r\npub fn poseidon_keystream(key: Field, nonce: u32) -> Field {\r\n    // === POSEIDON KEYSTREAM GENERATION ===\r\n    // Generate keystream using Poseidon with key and nonce\r\n    \r\n    // Use the public hash function with key and nonce\r\n    Poseidon2::hash([key, nonce as Field], 2)\r\n}\r\n\r\n/// Encrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_encrypt(plaintext: Field, key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE ENCRYPTION ===\r\n    // Use Poseidon to generate keystream for CTR mode encryption\r\n    \r\n    // Generate keystream using Poseidon with key and counter\r\n    let keystream = poseidon_keystream(key, counter);\r\n    \r\n    // Encrypt by adding keystream to plaintext (field arithmetic equivalent of XOR)\r\n    let ciphertext = plaintext + keystream;\r\n    \r\n    ciphertext\r\n}\r\n\r\n/// Decrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_decrypt(ciphertext: Field, key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE DECRYPTION ===\r\n    // Decryption is the same as encryption in CTR mode\r\n    \r\n    // Generate the same keystream\r\n    let keystream = poseidon_keystream(key, counter);\r\n    \r\n    // Decrypt by subtracting keystream from ciphertext\r\n    let plaintext = ciphertext - keystream;\r\n    \r\n    plaintext\r\n}\r\n\r\n/// Encrypt all four fields (amount, token_address, ref, encryption_key) in one function call\r\n/// This provides integrity checking - the ref value can be verified when absorbing the note\r\npub fn poseidon_encrypt_all_fields(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> (Field, Field, Field, Field) {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ===\r\n    // Encrypt all four fields with different counters in one function call\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    let encrypted_key = poseidon_ctr_encrypt(encryption_key, encryption_key, 3);\r\n    \r\n    (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n/// Encrypt all four fields and return as array for cleaner API\r\npub fn poseidon_encrypt_all_fields_array(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> [Field; 3] {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ARRAY ===\r\n    // Encrypt all four fields and return the first 3 as an array\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    \r\n    [encrypted_amount, encrypted_token_address, encrypted_ref]\r\n}\r\n\r\n// ===== BASIC FUNCTIONALITY TESTS =====\r\n\r\n#[test]\r\nfn test_basic_encryption_decryption() {\r\n    // Test basic encryption and decryption round-trip\r\n    let plaintext = 12345 as Field;\r\n    let key = Poseidon2::hash([42 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_zero_plaintext() {\r\n    // Test encryption of zero value\r\n    let plaintext = 0 as Field;\r\n    let key = Poseidon2::hash([123 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_large_plaintext() {\r\n    // Test encryption of large field value (using a large but valid field value)\r\n    let plaintext = 21888242871839275222246405745257275088548364400416034343698204186575808495616 as Field; // p-1\r\n    let key = Poseidon2::hash([456 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n// ===== COUNTER/KEYSTREAM TESTS =====\r\n\r\n#[test]\r\nfn test_different_counters_produce_different_ciphertexts() {\r\n    // Test that different counters produce different ciphertexts\r\n    let plaintext = 1000 as Field;\r\n    let key = Poseidon2::hash([789 as Field], 1);\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, key, 0);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, key, 1);\r\n    let ciphertext3 = poseidon_ctr_encrypt(plaintext, key, 2);\r\n    \r\n    // All ciphertexts should be different\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n    \r\n    // But all should decrypt to the same plaintext\r\n    assert(poseidon_ctr_decrypt(ciphertext1, key, 0) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext2, key, 1) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext3, key, 2) == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_consistency() {\r\n    // Test that same inputs produce same keystream\r\n    let key = Poseidon2::hash([999 as Field], 1);\r\n    let nonce = 5 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(key, nonce);\r\n    let keystream2 = poseidon_keystream(key, nonce);\r\n    \r\n    assert(keystream1 == keystream2);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_nonces() {\r\n    // Test that different nonces produce different keystreams\r\n    let key = Poseidon2::hash([111 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(key, 0);\r\n    let keystream2 = poseidon_keystream(key, 1);\r\n    let keystream3 = poseidon_keystream(key, 2);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_keys() {\r\n    // Test that different keys produce different keystreams\r\n    let nonce = 0 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(Poseidon2::hash([1 as Field], 1), nonce);\r\n    let keystream2 = poseidon_keystream(Poseidon2::hash([2 as Field], 1), nonce);\r\n    let keystream3 = poseidon_keystream(Poseidon2::hash([3 as Field], 1), nonce);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n// ===== BATCH ENCRYPTION TESTS =====\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_basic() {\r\n    // Test batch encryption of all four fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Verify each field can be decrypted individually\r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_zero_values() {\r\n    // Test batch encryption with zero values\r\n    let amount = 0 as Field;\r\n    let token_address = 0 as Field;\r\n    let ref = 0 as Field;\r\n    let encryption_key = Poseidon2::hash([0 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_different_keys() {\r\n    // Test that different encryption keys produce different results\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    \r\n    let key1 = Poseidon2::hash([111 as Field], 1);\r\n    let key2 = Poseidon2::hash([222 as Field], 1);\r\n    \r\n    let (enc1_amount, enc1_token, enc1_ref, enc1_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key1\r\n    );\r\n    \r\n    let (enc2_amount, enc2_token, enc2_ref, enc2_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key2\r\n    );\r\n    \r\n    // Different keys should produce different ciphertexts\r\n    assert(enc1_amount != enc2_amount);\r\n    assert(enc1_token != enc2_token);\r\n    assert(enc1_ref != enc2_ref);\r\n    assert(enc1_key != enc2_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_integrity_check() {\r\n    // Test that the ref and key values provide integrity checking\r\n    let amount = 5000 as Field;\r\n    let token_address = 6000 as Field;\r\n    let ref = 7000 as Field;\r\n    let encryption_key = Poseidon2::hash([777 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Decrypt the ref and key values - they should match the original values\r\n    let decrypted_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n    // This provides integrity: if someone tries to use a different key to decrypt,\r\n    // the values won't match, indicating tampering\r\n    let wrong_key = Poseidon2::hash([888 as Field], 1);\r\n    let wrong_decrypted_ref = poseidon_ctr_decrypt(enc_ref, wrong_key, 2);\r\n    let wrong_decrypted_key = poseidon_ctr_decrypt(enc_key, wrong_key, 3);\r\n    assert(wrong_decrypted_ref != ref);\r\n    assert(wrong_decrypted_key != encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_array() {\r\n    // Test the array version of encrypt all fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let encrypted_array = poseidon_encrypt_all_fields_array(amount, token_address, ref, encryption_key);\r\n    \r\n    // Verify array has 3 elements\r\n    assert(encrypted_array.len() == 3);\r\n    \r\n    // Verify each element can be decrypted\r\n    let dec_amount = poseidon_ctr_decrypt(encrypted_array[0], encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(encrypted_array[1], encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(encrypted_array[2], encryption_key, 2);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n}\r\n\r\n// ===== SECURITY TESTS =====\r\n\r\n#[test]\r\nfn test_wrong_key_fails_decryption() {\r\n    // Test that decryption with wrong key fails\r\n    let plaintext = 5000 as Field;\r\n    let correct_key = Poseidon2::hash([111 as Field], 1);\r\n    let wrong_key = Poseidon2::hash([222 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, correct_key, counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, wrong_key, counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_wrong_counter_fails_decryption() {\r\n    // Test that decryption with wrong counter fails\r\n    let plaintext = 7777 as Field;\r\n    let key = Poseidon2::hash([333 as Field], 1);\r\n    let correct_counter = 2 as u32;\r\n    let wrong_counter = 3 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, correct_counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, key, wrong_counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_deterministic() {\r\n    // Test that same inputs always produce same ciphertext\r\n    let plaintext = 8888 as Field;\r\n    let key = Poseidon2::hash([444 as Field], 1);\r\n    let counter = 1 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    \r\n    // Same inputs should produce same ciphertext\r\n    assert(ciphertext1 == ciphertext2);\r\n}\r\n\r\n#[test]\r\nfn test_different_plaintexts_different_ciphertexts() {\r\n    // Test that different plaintexts produce different ciphertexts\r\n    let key = Poseidon2::hash([555 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(1000 as Field, key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(2000 as Field, key, counter);\r\n    let ciphertext3 = poseidon_ctr_encrypt(3000 as Field, key, counter);\r\n    \r\n    // Different plaintexts should produce different ciphertexts\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n}\r\n\r\n// ===== EDGE CASE TESTS =====\r\n\r\n#[test]\r\nfn test_max_counter_value() {\r\n    // Test with maximum counter value\r\n    let plaintext = 1234 as Field;\r\n    let key = Poseidon2::hash([666 as Field], 1);\r\n    let max_counter = 4294967295 as u32; // u32::MAX\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, max_counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, max_counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_preserves_field_arithmetic() {\r\n    // Test that encryption preserves field arithmetic properties\r\n    let a = 1000 as Field;\r\n    let b = 2000 as Field;\r\n    let key = Poseidon2::hash([777 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    // Encrypt individual values\r\n    let enc_a = poseidon_ctr_encrypt(a, key, counter);\r\n    let enc_b = poseidon_ctr_encrypt(b, key, counter);\r\n    \r\n    // Decrypt and verify\r\n    let dec_a = poseidon_ctr_decrypt(enc_a, key, counter);\r\n    let dec_b = poseidon_ctr_decrypt(enc_b, key, counter);\r\n    \r\n    assert(dec_a == a);\r\n    assert(dec_b == b);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_uniformity() {\r\n    // Test that keystreams appear uniformly distributed\r\n    let key = Poseidon2::hash([888 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(key, 0);\r\n    let keystream2 = poseidon_keystream(key, 1);\r\n    let keystream3 = poseidon_keystream(key, 2);\r\n    let keystream4 = poseidon_keystream(key, 3);\r\n    let keystream5 = poseidon_keystream(key, 4);\r\n    \r\n    // All keystreams should be different (very high probability)\r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream3 != keystream4);\r\n    assert(keystream4 != keystream5);\r\n    assert(keystream1 != keystream3);\r\n    assert(keystream1 != keystream4);\r\n    assert(keystream1 != keystream5);\r\n    assert(keystream2 != keystream4);\r\n    assert(keystream2 != keystream5);\r\n    assert(keystream3 != keystream5);\r\n}\r\n\r\n// ===== TEST FOR TYPESCRIPT COMPARISON =====\r\n\r\n/// Get test values for TypeScript comparison\r\npub fn get_poseidon_ctr_test_values() -> (Field, Field, Field, Field, Field, Field, Field, Field) {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Return all values for external testing\r\n    (amount, token_address, ref, encryption_key, encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n#[test]\r\nfn test_poseidon_ctr_encryption_values() {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Decrypt all fields\r\n    let decrypted_amount = poseidon_ctr_decrypt(encrypted_amount, encryption_key, 0);\r\n    let decrypted_token_address = poseidon_ctr_decrypt(encrypted_token_address, encryption_key, 1);\r\n    let decrypted_ref = poseidon_ctr_decrypt(encrypted_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(encrypted_key, encryption_key, 3);\r\n    \r\n    // Verify round-trip encryption/decryption\r\n    assert(decrypted_amount == amount);\r\n    assert(decrypted_token_address == token_address);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n \r\n    println(\"Encrypted amount: 0x{:x}\");\r\n    println(encrypted_amount);\r\n    println(\"Encrypted token address: 0x{:x}\");\r\n    println(encrypted_token_address);\r\n    println(\"Encrypted ref: 0x{:x}\");\r\n    println(encrypted_ref);\r\n    println(\"Encrypted key: 0x{:x}\");\r\n    println(encrypted_key);\r\n    println(\"Decrypted amount: 0x{:x}\");\r\n    println(decrypted_amount);\r\n    println(\"Decrypted token address: 0x{:x}\");\r\n    println(decrypted_token_address);\r\n    println(\"Decrypted ref: 0x{:x}\");\r\n    println(decrypted_ref);\r\n    println(\"Decrypted key: 0x{:x}\");\r\n    println(decrypted_key);\r\n}\r\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon-ctr-encryption/src/lib.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}