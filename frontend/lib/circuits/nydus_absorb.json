{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":14298593398571336857,"abi":{"parameters":[{"name":"user_key","type":{"kind":"field"},"visibility":"private"},{"name":"token_address","type":{"kind":"field"},"visibility":"private"},{"name":"previous_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"inner_notes_count","type":{"kind":"field"},"visibility":"private"},{"name":"main_c_tot","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"main_c_inner","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"main_c_outer","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"main_c_inner_point","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"main_c_outer_point","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"notes_c_tot","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"notes_c_inner","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"notes_c_outer","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"notes_c_inner_point","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"notes_c_outer_point","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_tot","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_inner","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_outer","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_inner_m","type":{"kind":"field"},"visibility":"private"},{"name":"personal_c_outer_m","type":{"kind":"field"},"visibility":"private"},{"name":"personal_c_outer_r","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"relay_fee_token_address","type":{"kind":"field"},"visibility":"public"},{"name":"receiver_fee_amount","type":{"kind":"field"},"visibility":"public"},{"name":"fee_token_personal_c_inner","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"fee_token_personal_c_outer","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"fee_token_personal_c_inner_m","type":{"kind":"field"},"visibility":"private"},{"name":"fee_token_personal_c_outer_m","type":{"kind":"field"},"visibility":"private"},{"name":"fee_token_personal_c_outer_r","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"array","length":2,"type":{"kind":"field"}},{"kind":"array","length":7,"type":{"kind":"field"}},{"kind":"array","length":2,"type":{"kind":"field"}},{"kind":"array","length":2,"type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"1594545760803050608":{"error_kind":"string","string":"Notes total commitment y verification failed"},"1612527314196857042":{"error_kind":"string","string":"Main total commitment y verification failed"},"1677026342693926814":{"error_kind":"string","string":"Notes outer commitment x verification failed"},"1773109170529334064":{"error_kind":"string","string":"Fee amount exceeds available fee token balance"},"1829188810346778472":{"error_kind":"string","string":"Main total commitment x verification failed"},"4424301419604396817":{"error_kind":"string","string":"Notes inner commitment x verification failed"},"4569021105688977959":{"error_kind":"string","string":"Notes outer commitment y verification failed"},"4595064417801177898":{"error_kind":"string","string":"Main outer commitment x verification failed"},"4870430370618040774":{"error_kind":"string","string":"Decrypted y coordinate doesn't match personal_c_tot"},"5016858004930596942":{"error_kind":"string","string":"Total commitment verification failed"},"5953736523571907205":{"error_kind":"string","string":"Main outer commitment y verification failed"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6662057465190892192":{"error_kind":"string","string":"Main inner commitment y verification failed"},"10612215498520620440":{"error_kind":"string","string":"Decrypted x coordinate doesn't match personal_c_tot"},"11045699237078081382":{"error_kind":"string","string":"Main inner commitment x verification failed"},"11111546544413083335":{"error_kind":"string","string":"Fee token inner commitment y verification failed"},"11518414281695999627":{"error_kind":"string","string":"Notes total commitment x verification failed"},"11740974266937565723":{"error_kind":"string","string":"Outer commitment verification failed"},"14721261026514454637":{"error_kind":"string","string":"Fee token outer commitment verification failed"},"14919676320828105352":{"error_kind":"string","string":"Fee token inner commitment x verification failed"},"15653880448467002131":{"error_kind":"string","string":"Inner commitment y verification failed"},"16280420461495783291":{"error_kind":"string","string":"Notes inner commitment y verification failed"},"17488629581918235323":{"error_kind":"string","string":"Insufficient balance for fee (including absorbed amount)"},"17493575164725668030":{"error_kind":"string","string":"Inner commitment x verification failed"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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g/G952erreRLDaXuPR+M7z0/+Q1kfO/52WpLzaVK3Xs+lLr3fHC797yz2lJ7qVL3ng+l7j0fSt17PpS693wode/5YHzv+cl3svG952erLfWMz+3e885qK/lSg9u9553VlppLud173lltpb/jG9zuPc//3Za693wode/5YHzv+cnuwu3e885qS+2lSt17PpS693xwu/e8s9pSeym3e8/zf7du9553PttSe6lS954Ppe49H9zuPe98J5faS7nde975Ti71jK/UvedDqXvPB7d7z/OfUm73nndWW2ov5XbveWe1pf6Or9S954Pbveedn1Kl3HO3e8/z72S3e887qy3lS5W693xwu/c8/ynldu95Z7Wl9lJu9553VltqLmV87/nZaku556XuPR+M7z0/+U52u/e8s9pScym3e887qy31jK/UveeD8b3nJ96F8b3nZ6st5UuVuvd8ML73/OyzLfWMz/je87PPtpX6bEvdiVDq3vPB+N7zs8+21DM+43vPXz/b0e3e8/SzHd3uPe98tpX2UqPxvednn20r9dlW2kuNbveedz7bSnupsdS956Pxvecnn63bvef5Z2t87/nZZ1tqL+V273nns22lPttSeym3e887n22pvVSpe89H43vPTz5bt3vP88/W7d7zzmdbai9V6t7z0e3e885nW2ovVere89H43vOzz7bUXsrt3vP8sy117/lofO/52Wdbai9lfO/52WfbSn22pfZSpe49H0vdez663Xve+WxL7aVK3Xs+lrr3fCx17/lY6t7zsdS952Ope8/HUveej2b3nrfH11c//+f4utq776WWbfxe7bK33pc/5v37yx/Lmn/5vk7b8dX72ubfv/gPOHffev1z4SzrN5xteoFz+1vV3wrn7hu7t8K5+z7wrXDuvm38p8LZpvYFZ5tffyDf/kb4fyqc57fOF5x9G17h3H1T+lY4d9/DvhXO3be8/0w4w+PxmL6+/Pm/t1c8lffIF/C47ZLH3/BM3V/nj/371/mwvMC5/X35b4Xjtkv+c3Dyw+ftb+N/Kxy3XfKfg5MfIW5/1/9b4bjtkv8UnM756vYlgbfCcdsl/yk4nSPE7TsFb4VTeofcgXP7CsJb4ZTeIffglN4h9+BU3iH3hxa3bzi8GU/pWXJnbHH7RsQ7n5nfPinxzod7ty9QvBVOadtie8zfh89hfIFz+77FOx8L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LLfe5b7PHtpuvc19I5db73PfyOXWG903crn1TveNXG691X0jl1vvdd/HZb/1ZveNXG69230jl1tvd9/Ihf3uOZd2ay5K4Xi/9xZWutR770qlS733RlO61HvvHYWF+n2/93ZQt9T98bj3Dk+61Htv2qRLvfc+TLrUe2+tpEttdZZqtFvqLdVot9Rb6l/fLT3Xt/xa6/Byr/7zRTbBiwzr91+UPMZxen2RXfAiy/x7F2HNv7xt38mF9vv2LDjRyVKq+2N4FFrrUGitY6G1TkZrTZObz7W2QmudC611KbTW1WitugjoE8wGmHMwTjsyXetyf4xO2zdd0vEJxmmvJwWj2Bi2778pf/7vfXs5QY3TT7xIE7zI/Pj+a/3H/I8f8R8votiDrNNvH/b6eH0RxS//bRq+X2T77Vvq+0VOf+vOv3J58zz3XmSZpu+BwTLtj94s4vZXLDyxbAIsbfoeWyy/X1LxwVh2AZZf13EMy7JMnS9f5++vXpeW//wUPqjeH+dlDtO1DoXWOhZa61Rora3QWudCa10KrXUttNat0FoL7ZvaG/ZN2/cWd3tsP7nWodBax0JrnQqttRVa61xorUuhta6F1roVWuteZ61zoX3T/OP7pvF5tvqamT5+G7b/L3jxz7c/fvbbnz777bd7v/2OETnPn/32l89+++tnv/3ts9/+/tFvf3l89tu/+W/d3tu/+W/d3ttX/NZdfknqyzq+mvCL4nfjuv1itE2vYsKi+A22T98ex/p49L78bdPMZSm01rXQWrdCa93rrHV9FFrrUGitY6G1ToXW2gqttdC+aX3Dvuld08x1LbTWrdBa9zpr3R6F1joUWutYaK1TobW2QmudC6210L5p+/F9k/Q55LZ99tvfP/rt7497v/3O04B9+Oy3P372258+++23z37782e//eWz3/7Nf+v23v7Nf+v23r7gt+76GNZfb39++Rv44SH43bgOw/efAq/DPL2+iOA32Dou38+z12kY8y//hD+RHh6C34xre3z/5fja1rsOeYfHVGitrdBa50JrXQqtdS201q3QWvc6ax0ehdY6FFproX3T8IZ905uGvMPQCq11LrTWpdBa10Jr3Qqtda+z1vFRaK1DobWOhdZaaN80/vi+Sfl4dhjnz377y2e//fXebz9/SDKM22e//f2j3/70+Oy3P3z22x8/++1Pn/32b/5bt/f2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","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"use dep::std;\nuse dep::std::field::bn254::{assert_gt, gt, assert_lt, lt};\nuse dep::poseidon::poseidon2::Poseidon2;\nuse dep::poseidon_ctr_encryption::{poseidon_ctr_encrypt, poseidon_ctr_decrypt};\nuse dep::ec::tecurve::affine::{Point};\nuse dep::ec::consts::te::{baby_jubjub};\nuse dep::pedersen_commitments::pedersen_commitments::{\n    pedersen_commitment_positive,\n    pedersen_commitment_negative,\n    pedersen_commitment_counter,\n    add_commitments,\n    add_multiple_commitments,\n    pedersen_commitment_non_hiding,\n    to_nullifier_domain,\n    subtract_commitments\n};\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint;\nmod test;\n\nglobal VIEW_STRING: Field = 0x76696577696e675f6b6579 as Field;\n\n// Initialized commitment point: pedersen_commitment_positive(1, 1, 1)\n// Used as default notes_c_outer when there are no other notes\nglobal INITIALIZED_COMMITMENT_X: Field = 0x0bc6f794fe53f0c8704d41006c06065f765e884d12ea6841895866f6a7796568 as Field;\nglobal INITIALIZED_COMMITMENT_Y: Field = 0x22539c9ee4342d7eaa4c5a67d5cb0c93ddf1e9e03c173e6a4e442b5d57a2b5bd as Field;\n\nfn main(\n    user_key: Field,\n    token_address: Field,\n    previous_nonce: Field, \n    inner_notes_count: Field,              // Number of notes being absorbed for this token\n\n    // Main stack commitments (user's own commitments)\n    main_c_tot: pub [Field; 2],               // Main total commitment\n    main_c_inner: [Field; 2],             // Main inner commitment\n    main_c_outer: [Field; 2],             // Main outer commitment\n    main_c_inner_point: [Field; 2],       // Opening values for main inner commitment\n    main_c_outer_point: [Field; 3],       // Opening values for main outer commitment\n\n    // Notes stack commitments (incoming note commitments)\n    // notes_c_tot is no longer public - it's verified as part of main_c_tot structure\n    notes_c_tot: [Field; 2],               // Notes total commitment (private, verified in main commitment)\n    notes_c_inner: [Field; 2],             // Notes inner commitment (sum of all notes for this token)\n    notes_c_outer: [Field; 2],             // Notes outer commitment (sum of all other notes/commitments)\n    notes_c_inner_point: [Field; 2],       // Opening values: [sum of amounts, sum of shared_key_hashes]\n    notes_c_outer_point: [Field; 3],       // Opening values for notes outer commitment (for off-circuit construction)\n\n    // Personal commitments (user's balance state)\n    personal_c_tot: [Field; 2],           // Personal total commitment\n    personal_c_inner: [Field; 2],         // Personal inner commitment\n    personal_c_outer: [Field; 2],         // Personal outer commitment\n    personal_c_inner_m: Field,            // Personal inner amount\n    personal_c_outer_m: Field,            // Personal outer amount  \n    personal_c_outer_r: Field,            // Personal outer blinding factor\n    nullifier: Field,                     // Current nullifier value (balance spent from notes)\n    \n    relay_fee_token_address: pub Field,\n    receiver_fee_amount: pub Field,\n    fee_token_personal_c_inner: [Field; 2],\n    fee_token_personal_c_outer: [Field; 2],\n    fee_token_personal_c_inner_m: Field,\n    fee_token_personal_c_outer_m: Field,\n    fee_token_personal_c_outer_r: Field\n) -> pub (Field, [Field; 2], [Field; 7], [Field; 2], [Field; 2]) {\n    // === NYDUS-ABSORB CIRCUIT (PERSONAL + NOTES COMMITMENTS) ===\n    // This circuit absorbs incoming note commitments into personal balance\n    // \n    // VERIFICATION FLOW:\n    // 1. Verify main_c_tot commitments (user's own commitments)\n    // 2. Verify notes_c_tot commitments (incoming note commitments)\n    // 3. Verify personal commitments (user's balance state)\n    // 4. Validate user has enough balance to absorb\n    // 5. Update personal balance with absorbed amount\n    // 6. Create new commitments and encrypted notes\n    \n    // === SETUP ===\n    let user_key_hash = Poseidon2::hash([user_key], 1);\n    let view_key = Poseidon2::hash([VIEW_STRING, user_key_hash], 2);\n    let previous_nonce_commitment = Poseidon2::hash([user_key_hash, previous_nonce as Field], 2);\n    let current_balance = personal_c_inner_m;\n    let fee_token_current_balance = fee_token_personal_c_inner_m;\n    let tokens_same = token_address == relay_fee_token_address;\n    \n    // === VERIFICATION ===\n    // Verify notes commitments first (to get notes_c_tot for main verification)\n    // This also verifies that the receiver's public key is committed in notes_c_outer\n    verify_notes_commitments(\n        notes_c_tot,\n        notes_c_inner,\n        notes_c_outer,\n        notes_c_inner_point,\n        notes_c_outer_point,\n        token_address,\n        inner_notes_count,\n        user_key\n    );\n    \n    // Verify main commitments with new structure: notes_c_tot + main_c_outer = main_c_tot\n    // (notes_c_tot is already verified separately, we just prove it's part of main_c_tot)\n    verify_main_commitments(\n        main_c_tot,\n        main_c_inner,\n        main_c_outer,\n        main_c_inner_point,\n        main_c_outer_point,\n        previous_nonce_commitment,\n        view_key,\n        previous_nonce,\n        notes_c_tot\n    );\n    \n    let initializer_was_initialized = verify_personal_commitments(\n        personal_c_tot,\n        personal_c_inner,\n        personal_c_outer,\n        personal_c_inner_m,\n        personal_c_outer_m,\n        personal_c_outer_r,\n        nullifier,\n        token_address,\n        user_key_hash,\n        main_c_inner_point,\n        view_key,\n        previous_nonce,\n        tokens_same,\n        fee_token_personal_c_inner\n    );\n    \n    if !tokens_same {\n        verify_fee_token_personal_commitments(\n            fee_token_personal_c_inner,\n            fee_token_personal_c_outer,\n            fee_token_personal_c_inner_m,\n            fee_token_personal_c_outer_m,\n            fee_token_personal_c_outer_r,\n            relay_fee_token_address,\n            user_key_hash\n        );\n    }\n    \n    // === PROCESSING ===\n    let nonce = previous_nonce + 1 as Field;\n    let new_nonce_commitment = Poseidon2::hash([user_key_hash, nonce as Field], 2);\n    \n    // Extract absorbed amount from notes inner commitment\n    // notes_c_inner_point[0] is the sum of all amounts from the notes being absorbed\n    let absorbed_amount = notes_c_inner_point[0];\n    \n    // === SUFFICIENT BALANCE CHECK ===\n    if tokens_same {\n        // When tokens are the same, fee can be paid from absorbed amount + current balance\n        assert(gt(current_balance + absorbed_amount, receiver_fee_amount - 1), \"Insufficient balance for fee (including absorbed amount)\");\n    } else {\n        assert(gt(fee_token_current_balance, receiver_fee_amount - 1), \"Fee amount exceeds available fee token balance\");\n    }\n    \n    // === UPDATE NULLIFIER ===\n    // Increase nullifier by absorbed amount (tracks balance spent from notes)\n    let new_nullifier = nullifier + absorbed_amount;\n    \n    // === CREATE NEW COMMITMENTS ===\n    let (new_main_commitment, enc_x, enc_y) = create_new_commitments(\n        current_balance,\n        absorbed_amount,\n        personal_c_tot,\n        personal_c_inner,\n        fee_token_personal_c_inner,\n        fee_token_current_balance,\n        receiver_fee_amount,\n        token_address,\n        relay_fee_token_address,\n        user_key_hash,\n        new_nonce_commitment,\n        initializer_was_initialized,\n        new_nullifier,\n        view_key,\n        nonce,\n        tokens_same\n    );\n    \n    // === ENCRYPT OPERATION DETAILS ===\n    let new_balance = if tokens_same {\n        current_balance + absorbed_amount - receiver_fee_amount\n    } else {\n        current_balance + absorbed_amount\n    };\n    \n    let encrypted_note = encrypt_operation_details(\n        current_balance,\n        token_address,\n        nonce,\n        view_key,\n        personal_c_tot,\n        personal_c_inner,\n        personal_c_inner_m,\n        fee_token_personal_c_inner,\n        fee_token_personal_c_inner_m,\n        fee_token_current_balance,\n        receiver_fee_amount,\n        absorbed_amount,\n        initializer_was_initialized,\n        user_key_hash,\n        relay_fee_token_address,\n        new_nullifier,\n        tokens_same\n    );\n    \n    let nonce_discovery_entry = pedersen_commitment_non_hiding(1, new_nonce_commitment);\n    \n    // === RETURN VALUES ===\n    (    \n        new_nonce_commitment,\n        [new_main_commitment.x, new_main_commitment.y],\n        encrypted_note,\n        [nonce_discovery_entry.x, nonce_discovery_entry.y],\n        [enc_x, enc_y]\n    )\n}\n\n\n\n\n\n\n// === HELPER FUNCTIONS ===\n\n/// Verify main stack commitments using opening values\n/// New structure: notes_c_tot + main_c_outer = main_c_tot\n/// (notes_c_tot is already verified separately via verify_notes_commitments)\nfn verify_main_commitments(\n    main_c_tot: [Field; 2],\n    main_c_inner: [Field; 2], \n    main_c_outer: [Field; 2],\n    main_c_inner_point: [Field; 2],\n    main_c_outer_point: [Field; 3],\n    previous_nonce_commitment: Field,\n    view_key: Field,\n    previous_nonce: Field,\n    notes_c_tot: [Field; 2]\n) {\n    // Verify that main_c_inner was created using the encrypted coordinates in main_c_inner_point\n    let reconstructed_main_c_inner = pedersen_commitment_positive(main_c_inner_point[0], main_c_inner_point[1], previous_nonce_commitment);\n    \n    // Additionally verify that the encrypted coordinates can be decrypted (verifying they are valid encrypted coordinates)\n    let previous_encryption_key = Poseidon2::hash([view_key, previous_nonce], 2);\n    let _decrypted_x = poseidon_ctr_decrypt(main_c_inner_point[0], previous_encryption_key, 3);\n    let _decrypted_y = poseidon_ctr_decrypt(main_c_inner_point[1], previous_encryption_key, 4);\n    assert(reconstructed_main_c_inner.x == main_c_inner[0], \"Main inner commitment x verification failed\");\n    assert(reconstructed_main_c_inner.y == main_c_inner[1], \"Main inner commitment y verification failed\");\n\n    // Verify outer commitment\n    let reconstructed_main_c_outer = pedersen_commitment_positive(main_c_outer_point[0], main_c_outer_point[1], main_c_outer_point[2]);\n    assert(reconstructed_main_c_outer.x == main_c_outer[0], \"Main outer commitment x verification failed\");\n    assert(reconstructed_main_c_outer.y == main_c_outer[1], \"Main outer commitment y verification failed\");\n\n    // New structure: notes_c_tot + main_c_outer = main_c_tot\n    // (notes_c_tot is already verified separately, we just prove it's part of main_c_tot)\n    let notes_c_tot_commitment = EmbeddedCurvePoint { x: notes_c_tot[0], y: notes_c_tot[1], is_infinite: false };\n    \n    // Verify total commitment: notes_c_tot + main_c_outer = main_c_tot\n    let main_c_tot_commitment = add_commitments(notes_c_tot_commitment, reconstructed_main_c_outer);\n    assert(main_c_tot_commitment.x == main_c_tot[0], \"Main total commitment x verification failed\");\n    assert(main_c_tot_commitment.y == main_c_tot[1], \"Main total commitment y verification failed\");\n}\n\n/// Verify notes stack commitments using opening values\n/// Structure: notes_c_tot = notes_c_inner + notes_c_outer + reference_commitment\n/// - notes_c_inner: sum of all notes for the token being absorbed\n/// - notes_c_outer: sum of all other notes/commitments (other tokens, etc.)\n/// - reference_commitment: pedersen_commitment_positive(pub_x, pub_y, 1) calculated in-circuit\n/// notes_c_inner is the sum of all notes for this token:\n///   - notes_c_inner_point[0] = sum of all amounts\n///   - notes_c_inner_point[1] = sum of all shared_key_hashes\n///   - third parameter = token_address * inner_notes_count\nfn verify_notes_commitments(\n    notes_c_tot: [Field; 2],\n    notes_c_inner: [Field; 2], \n    notes_c_outer: [Field; 2],\n    notes_c_inner_point: [Field; 2],\n    notes_c_outer_point: [Field; 3],\n    token_address: Field,\n    inner_notes_count: Field,\n    user_key: Field\n) {\n    // Verify inner commitment: sum of all notes for this token\n    // notes_c_inner_point[0] = sum of all amounts\n    // notes_c_inner_point[1] = sum of all shared_key_hashes\n    // third parameter = token_address * inner_notes_count (domain separation for multiple notes)\n    let token_address_with_count = token_address * inner_notes_count;\n    let reconstructed_notes_c_inner = pedersen_commitment_positive(notes_c_inner_point[0], notes_c_inner_point[1], token_address_with_count);\n    assert(reconstructed_notes_c_inner.x == notes_c_inner[0], \"Notes inner commitment x verification failed\");\n    assert(reconstructed_notes_c_inner.y == notes_c_inner[1], \"Notes inner commitment y verification failed\");\n\n    // Verify outer commitment (sum of all other notes/commitments)\n    // If there are no other notes, notes_c_outer should be the initialized commitment\n    // notes_c_outer_point contains opening values for off-circuit construction\n    // Always verify using notes_c_outer_point - it should reconstruct to notes_c_outer\n    let reconstructed_notes_c_outer = pedersen_commitment_positive(notes_c_outer_point[0], notes_c_outer_point[1], notes_c_outer_point[2]);\n    assert(reconstructed_notes_c_outer.x == notes_c_outer[0], \"Notes outer commitment x verification failed\");\n    assert(reconstructed_notes_c_outer.y == notes_c_outer[1], \"Notes outer commitment y verification failed\");\n\n    // === CALCULATE REFERENCE COMMITMENT IN-CIRCUIT ===\n    // Derive receiver's public key from user_key (same as in send circuit)\n    let bjj = baby_jubjub();\n    let generator = bjj.base8;\n    let receiver_public_key = bjj.curve.mul(user_key, generator);\n    \n    // Reference commitment: pedersen_commitment_positive(pub_x, pub_y, 1)\n    let reference_commitment = pedersen_commitment_positive(receiver_public_key.x, receiver_public_key.y, 1);\n\n    // Verify total commitment: notes_c_tot = notes_c_inner + notes_c_outer + reference_commitment\n    let notes_c_inner_commitment = EmbeddedCurvePoint { x: notes_c_inner[0], y: notes_c_inner[1], is_infinite: false };\n    let notes_c_outer_commitment = EmbeddedCurvePoint { x: notes_c_outer[0], y: notes_c_outer[1], is_infinite: false };\n    let notes_c_tot_commitment = add_multiple_commitments([\n        notes_c_inner_commitment,\n        notes_c_outer_commitment,\n        reference_commitment\n    ]);\n    assert(notes_c_tot_commitment.x == notes_c_tot[0], \"Notes total commitment x verification failed\");\n    assert(notes_c_tot_commitment.y == notes_c_tot[1], \"Notes total commitment y verification failed\");\n}\n\nfn verify_fee_token_personal_commitments(\n    fee_token_personal_c_inner: [Field; 2],\n    fee_token_personal_c_outer: [Field; 2],\n    fee_token_personal_c_inner_m: Field,\n    fee_token_personal_c_outer_m: Field,\n    fee_token_personal_c_outer_r: Field,\n    relay_fee_token_address: Field,\n    user_key_hash: Field\n) {\n    let fee_token_personal_c_inner_m_hash = Poseidon2::hash([fee_token_personal_c_inner_m, user_key_hash], 2);\n    let fee_token_personal_c_inner_token_address_hash = Poseidon2::hash([relay_fee_token_address, user_key_hash], 2);\n    \n    let fee_token_inner_commitment = pedersen_commitment_non_hiding(fee_token_personal_c_inner_m_hash, fee_token_personal_c_inner_token_address_hash);\n    assert(fee_token_inner_commitment.x == fee_token_personal_c_inner[0], \"Fee token inner commitment x verification failed\");\n    assert(fee_token_inner_commitment.y == fee_token_personal_c_inner[1], \"Fee token inner commitment y verification failed\");\n    \n    let fee_token_outer_commitment = pedersen_commitment_non_hiding(fee_token_personal_c_outer_m, fee_token_personal_c_outer_r);\n    assert(fee_token_outer_commitment.x == fee_token_personal_c_outer[0], \"Fee token outer commitment verification failed\");\n    assert(fee_token_outer_commitment.y == fee_token_personal_c_outer[1], \"Fee token outer commitment verification failed\");\n}\n\n/// Verify personal commitments and determine if initializer was initialized\nfn verify_personal_commitments(\n    personal_c_tot: [Field; 2],\n    personal_c_inner: [Field; 2],\n    personal_c_outer: [Field; 2],\n    personal_c_inner_m: Field,\n    personal_c_outer_m: Field,\n    personal_c_outer_r: Field,\n    nullifier: Field,\n    token_address: Field,\n    user_key_hash: Field,\n    main_c_inner_point: [Field; 2],\n    view_key: Field,\n    previous_nonce: Field,\n    tokens_same: bool,\n    fee_token_personal_c_inner: [Field; 2]\n) -> bool {\n    // Hash inner commitment parameters (balance)\n    let personal_c_inner_m_hash = Poseidon2::hash([personal_c_inner_m, user_key_hash], 2);\n    let personal_c_inner_token_address_hash = Poseidon2::hash([token_address, user_key_hash], 2);\n    \n    // Verify inner commitment (balance)\n    let inner_balance_commitment = pedersen_commitment_non_hiding(personal_c_inner_m_hash, personal_c_inner_token_address_hash);\n    assert(inner_balance_commitment.x == personal_c_inner[0], \"Inner commitment x verification failed\");\n    assert(inner_balance_commitment.y == personal_c_inner[1], \"Inner commitment y verification failed\");\n\n    // Verify outer commitment\n    let outer_commitment = pedersen_commitment_non_hiding(personal_c_outer_m, personal_c_outer_r);\n    assert(outer_commitment.x == personal_c_outer[0], \"Outer commitment verification failed\");\n    assert(outer_commitment.y == personal_c_outer[1], \"Outer commitment verification failed\");\n    \n    // Construct nullifier commitment\n    let nullifier_hashed = Poseidon2::hash([nullifier, user_key_hash], 2);\n    let nullifier_domain = to_nullifier_domain(token_address);\n    let nullifier_commitment = pedersen_commitment_non_hiding(nullifier_hashed, nullifier_domain);\n    \n    // Check if nullifier is 0 (first time, needs initializer)\n    let nullifier_is_zero = nullifier == 0;\n    \n    // If nullifier is 0: inner (balance) + initializer + outer = tot\n    // If nullifier > 0: inner (balance) + inner (nullifier) + outer = tot\n    let initializer = pedersen_commitment_non_hiding(token_address, user_key_hash);\n    \n    let sum_with_nullifier = add_multiple_commitments([\n        inner_balance_commitment,\n        nullifier_commitment,\n        outer_commitment\n    ]);\n    \n    let sum_with_initializer = add_multiple_commitments([\n        inner_balance_commitment,\n        initializer,\n        outer_commitment\n    ]);\n    \n    let with_nullifier_matches = (sum_with_nullifier.x == personal_c_tot[0]) & (sum_with_nullifier.y == personal_c_tot[1]);\n    let with_initializer_matches = (sum_with_initializer.x == personal_c_tot[0]) & (sum_with_initializer.y == personal_c_tot[1]);\n    \n    if tokens_same {\n        let matches = if nullifier_is_zero {\n            with_initializer_matches\n        } else {\n            with_nullifier_matches\n        };\n        assert(matches, \"Total commitment verification failed\");\n    } else {\n        let fee_token_personal_c_inner_commitment = EmbeddedCurvePoint { x: fee_token_personal_c_inner[0], y: fee_token_personal_c_inner[1], is_infinite: false };\n        let personal_c_tot_commitment = EmbeddedCurvePoint { x: personal_c_tot[0], y: personal_c_tot[1], is_infinite: false };\n        \n        let computed_outer = subtract_commitments(\n            subtract_commitments(personal_c_tot_commitment, inner_balance_commitment),\n            fee_token_personal_c_inner_commitment\n        );\n        \n        let sum_with_nullifier_combined = add_multiple_commitments([\n            inner_balance_commitment,\n            nullifier_commitment,\n            computed_outer,\n            fee_token_personal_c_inner_commitment\n        ]);\n        \n        let sum_with_initializer_combined = add_multiple_commitments([\n            inner_balance_commitment,\n            initializer,\n            computed_outer,\n            fee_token_personal_c_inner_commitment\n        ]);\n        \n        let with_nullifier_combined_matches = (sum_with_nullifier_combined.x == personal_c_tot[0]) & (sum_with_nullifier_combined.y == personal_c_tot[1]);\n        let with_initializer_combined_matches = (sum_with_initializer_combined.x == personal_c_tot[0]) & (sum_with_initializer_combined.y == personal_c_tot[1]);\n        \n        let matches = if nullifier_is_zero {\n            with_initializer_combined_matches\n        } else {\n            with_nullifier_combined_matches\n        };\n        assert(matches, \"Total commitment verification failed\");\n    }\n    \n    // Decrypt the encrypted coordinates from main_c_inner_point and verify they match personal_c_tot\n    let previous_encryption_key = Poseidon2::hash([view_key, previous_nonce], 2);\n    let decrypted_x = poseidon_ctr_decrypt(main_c_inner_point[0], previous_encryption_key, 3);\n    let decrypted_y = poseidon_ctr_decrypt(main_c_inner_point[1], previous_encryption_key, 4);\n    \n    // Verify decrypted coordinates match personal_c_tot\n    assert(decrypted_x == personal_c_tot[0], \"Decrypted x coordinate doesn't match personal_c_tot\");\n    assert(decrypted_y == personal_c_tot[1], \"Decrypted y coordinate doesn't match personal_c_tot\");\n    \n    // Return true if initializer was initialized (nullifier > 0 means it was initialized)\n    !nullifier_is_zero\n}\n\n/// Create new commitments after absorb\nfn create_new_commitments(\n    current_balance: Field,\n    absorbed_amount: Field,\n    personal_c_tot: [Field; 2],\n    personal_c_inner: [Field; 2],\n    fee_token_personal_c_inner: [Field; 2],\n    fee_token_current_balance: Field,\n    receiver_fee_amount: Field,\n    token_address: Field,\n    relay_fee_token_address: Field,\n    user_key_hash: Field,\n    new_nonce_commitment: Field,\n    initializer_was_initialized: bool,\n    new_nullifier: Field,\n    view_key: Field,\n    nonce: Field,\n    tokens_same: bool\n) -> (EmbeddedCurvePoint, Field, Field) {\n    let personal_c_tot_commitment = EmbeddedCurvePoint { x: personal_c_tot[0], y: personal_c_tot[1], is_infinite: false };\n    let personal_c_inner_commitment = EmbeddedCurvePoint { x: personal_c_inner[0], y: personal_c_inner[1], is_infinite: false };\n    \n    let outer_commitment = if tokens_same {\n        subtract_commitments(personal_c_tot_commitment, personal_c_inner_commitment)\n    } else {\n        let fee_token_personal_c_inner_commitment = EmbeddedCurvePoint { x: fee_token_personal_c_inner[0], y: fee_token_personal_c_inner[1], is_infinite: false };\n        subtract_commitments(\n            subtract_commitments(personal_c_tot_commitment, personal_c_inner_commitment),\n            fee_token_personal_c_inner_commitment\n        )\n    };\n    \n    let new_balance = if tokens_same {\n        current_balance + absorbed_amount - receiver_fee_amount\n    } else {\n        current_balance + absorbed_amount\n    };\n    \n    let new_balance_hash = Poseidon2::hash([new_balance, user_key_hash], 2);\n    let token_address_hash = Poseidon2::hash([token_address, user_key_hash], 2);\n    let new_balance_commitment = pedersen_commitment_non_hiding(new_balance_hash, token_address_hash);\n    \n    let new_nullifier_hashed = Poseidon2::hash([new_nullifier, user_key_hash], 2);\n    let nullifier_domain = to_nullifier_domain(token_address);\n    let new_nullifier_commitment = pedersen_commitment_non_hiding(new_nullifier_hashed, nullifier_domain);\n    \n    let new_personal_c_tot_commitment = if tokens_same {\n        if initializer_was_initialized {\n            add_multiple_commitments([\n                outer_commitment,\n                new_balance_commitment,\n                new_nullifier_commitment\n            ])\n        } else {\n            let initializer = pedersen_commitment_non_hiding(token_address, user_key_hash);\n            add_multiple_commitments([\n                outer_commitment,\n                new_balance_commitment,\n                initializer\n            ])\n        }\n    } else {\n        let fee_token_new_balance = fee_token_current_balance - receiver_fee_amount;\n        let fee_token_new_balance_hash = Poseidon2::hash([fee_token_new_balance, user_key_hash], 2);\n        let fee_token_token_address_hash = Poseidon2::hash([relay_fee_token_address, user_key_hash], 2);\n        let new_fee_balance_commitment = pedersen_commitment_non_hiding(fee_token_new_balance_hash, fee_token_token_address_hash);\n        \n        if initializer_was_initialized {\n            add_multiple_commitments([\n                outer_commitment,\n                new_balance_commitment,\n                new_nullifier_commitment,\n                new_fee_balance_commitment\n            ])\n        } else {\n            let initializer = pedersen_commitment_non_hiding(token_address, user_key_hash);\n            add_multiple_commitments([\n                outer_commitment,\n                new_balance_commitment,\n                initializer,\n                new_fee_balance_commitment\n            ])\n        }\n    };\n    \n    let encryption_key = Poseidon2::hash([view_key, nonce], 2);\n    let enc_x = poseidon_ctr_encrypt(new_personal_c_tot_commitment.x, encryption_key, 3);\n    let enc_y = poseidon_ctr_encrypt(new_personal_c_tot_commitment.y, encryption_key, 4);\n    \n    let new_main_commitment = pedersen_commitment_positive(\n        enc_x,\n        enc_y,\n        new_nonce_commitment\n    );\n    \n    // Return the new main commitment and encrypted coordinates\n    (new_main_commitment, enc_x, enc_y)\n}\n\n/// Encrypt operation details for privacy\nfn encrypt_operation_details(\n    current_balance: Field,\n    token_address: Field,\n    nonce: Field,\n    view_key: Field,\n    personal_c_tot: [Field; 2],\n    personal_c_inner: [Field; 2],\n    personal_c_inner_m: Field,\n    fee_token_personal_c_inner: [Field; 2],\n    fee_token_personal_c_inner_m: Field,\n    fee_token_current_balance: Field,\n    receiver_fee_amount: Field,\n    absorbed_amount: Field,\n    initializer_was_initialized: bool,\n    user_key_hash: Field,\n    relay_fee_token_address: Field,\n    new_nullifier: Field,\n    tokens_same: bool\n) -> [Field; 7] {\n    let encryption_key = Poseidon2::hash([view_key, nonce], 2);\n    \n    let new_balance = if tokens_same {\n        current_balance + absorbed_amount - receiver_fee_amount\n    } else {\n        current_balance + absorbed_amount\n    };\n    \n    let new_balance_hash = Poseidon2::hash([new_balance, user_key_hash], 2);\n    let token_address_hash = Poseidon2::hash([token_address, user_key_hash], 2);\n    \n    let new_nullifier_hash = Poseidon2::hash([new_nullifier, user_key_hash], 2);\n    let nullifier_domain = to_nullifier_domain(token_address);\n    \n    let personal_c_outer_m = 0 as Field;\n    let personal_c_outer_r = token_address;\n    \n    let personal_c_tot_m = if tokens_same {\n        if initializer_was_initialized {\n            new_balance_hash + new_nullifier_hash + personal_c_outer_m\n        } else {\n            new_balance_hash + token_address + personal_c_outer_m\n        }\n    } else {\n        let fee_token_new_balance = fee_token_current_balance - receiver_fee_amount;\n        let fee_token_new_balance_hash = Poseidon2::hash([fee_token_new_balance, user_key_hash], 2);\n        let fee_token_token_address_hash = Poseidon2::hash([relay_fee_token_address, user_key_hash], 2);\n        \n        if initializer_was_initialized {\n            new_balance_hash + new_nullifier_hash + personal_c_outer_m + fee_token_new_balance_hash\n        } else {\n            new_balance_hash + token_address + personal_c_outer_m + fee_token_new_balance_hash\n        }\n    };\n    \n    let personal_c_tot_r = if tokens_same {\n        if initializer_was_initialized {\n            token_address_hash + nullifier_domain + personal_c_outer_r\n        } else {\n            token_address_hash + user_key_hash + personal_c_outer_r\n        }\n    } else {\n        let fee_token_token_address_hash = Poseidon2::hash([relay_fee_token_address, user_key_hash], 2);\n        \n        if initializer_was_initialized {\n            token_address_hash + nullifier_domain + personal_c_outer_r + fee_token_token_address_hash\n        } else {\n            token_address_hash + user_key_hash + personal_c_outer_r + fee_token_token_address_hash\n        }\n    };\n\n    // Encrypt new balance (use counter 0 for consistency with deposit/send/withdraw circuits)\n    // This matches the pattern: encrypted_amount uses counter 0, encrypted_token_address uses counter 1\n    let encrypted_new_balance = poseidon_ctr_encrypt(new_balance, encryption_key, 0);\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\n    \n    // Self-reference check: encrypt hash of encryption_key for decryption verification\n    let encryption_key_hash = Poseidon2::hash([encryption_key], 1);\n    let encrypted_reference = poseidon_ctr_encrypt(encryption_key_hash, encryption_key, 2);\n    \n    // Encrypt absorbed amount (for tracking purposes)\n    let encrypted_absorbed_amount = poseidon_ctr_encrypt(absorbed_amount, encryption_key, 3);\n    \n    // Encrypt opening values for personal_c_tot\n    let encrypted_personal_c_tot_m = poseidon_ctr_encrypt(personal_c_tot_m, encryption_key, 4);\n    let encrypted_personal_c_tot_r = poseidon_ctr_encrypt(personal_c_tot_r, encryption_key, 5);\n    \n    // Encrypt new nullifier (current nullifier after update)\n    let encrypted_new_nullifier = poseidon_ctr_encrypt(new_nullifier, encryption_key, 6);\n    \n    [encrypted_absorbed_amount, encrypted_token_address, encrypted_reference, encrypted_new_balance, encrypted_personal_c_tot_m, encrypted_personal_c_tot_r, encrypted_new_nullifier]\n}\n","path":"/home/drone/projects/ethrome25/circuits/main/nydus-absorb/src/main.nr"},"69":{"source":"pub mod affine {\n    // Affine coordinate representation of Twisted Edwards curves\n    // Points are represented by two-dimensional Cartesian coordinates.\n    // Group operations are implemented in terms of those in CurveGroup (in this case, extended Twisted Edwards) coordinates\n    // for reasons of efficiency.\n    // See <https://eprint.iacr.org/2008/522.pdf> for details.\n    use crate::{\n        montcurve::affine::{Curve as MCurve, Point as MPoint},\n        swcurve::affine::{Curve as SWCurve, Point as SWPoint}, tecurve::curvegroup,\n    };\n    use std::cmp::Eq;\n\n    // Curve specification\n    pub struct Curve { // Twisted Edwards curve\n        // Coefficients in defining equation ax^2 + y^2 = 1 + dx^2y^2\n        pub a: Field,\n        pub d: Field,\n        // Generator as point in Cartesian coordinates\n        pub gen: Point,\n    }\n    // Point in Cartesian coordinates\n    pub struct Point {\n        pub x: Field,\n        pub y: Field,\n    }\n\n    impl Point {\n        // Point constructor\n        // #[deprecated(\"It's recommmended to use the external noir-edwards library (https://github.com/noir-lang/noir-edwards)\")]\n        pub fn new(x: Field, y: Field) -> Self {\n            Self { x, y }\n        }\n\n        // Check if zero\n        pub fn is_zero(self) -> bool {\n            self.eq(Point::zero())\n        }\n\n        // Conversion to CurveGroup coordinates\n        pub fn into_group(self) -> curvegroup::Point {\n            let Self { x, y } = self;\n\n            curvegroup::Point::new(x, y, x * y, 1)\n        }\n\n        // Additive identity\n        pub fn zero() -> Self {\n            Point::new(0, 1)\n        }\n\n        // Negation\n        pub fn negate(self) -> Self {\n            let Self { x, y } = self;\n            Point::new(0 - x, y)\n        }\n\n        // Map into prime-order subgroup of equivalent Montgomery curve\n        pub fn into_montcurve(self) -> MPoint {\n            if self.is_zero() {\n                MPoint::zero()\n            } else {\n                let Self { x, y } = self;\n                let x0 = (1 + y) / (1 - y);\n                let y0 = (1 + y) / (x * (1 - y));\n\n                MPoint::new(x0, y0)\n            }\n        }\n    }\n\n    impl Eq for Point {\n        fn eq(self, p: Self) -> bool {\n            let Self { x: x1, y: y1 } = self;\n            let Self { x: x2, y: y2 } = p;\n\n            (x1 == x2) & (y1 == y2)\n        }\n    }\n\n    impl Curve {\n        // Curve constructor\n        pub fn new(a: Field, d: Field, gen: Point) -> Curve {\n            // Check curve coefficients\n            assert(a * d * (a - d) != 0);\n\n            let curve = Curve { a, d, gen };\n\n            // gen should be on the curve\n            assert(curve.contains(curve.gen));\n\n            curve\n        }\n\n        // Conversion to CurveGroup coordinates\n        pub fn into_group(self) -> curvegroup::Curve {\n            let Curve { a, d, gen } = self;\n\n            curvegroup::Curve { a, d, gen: gen.into_group() }\n        }\n\n        // Membership check\n        pub fn contains(self, p: Point) -> bool {\n            let Point { x, y } = p;\n            self.a * x * x + y * y == 1 + self.d * x * x * y * y\n        }\n\n        // Point addition, implemented in terms of mixed addition for reasons of efficiency\n        pub fn add(self, p1: Point, p2: Point) -> Point {\n            self.mixed_add(p1, p2.into_group()).into_affine()\n        }\n\n        // Mixed point addition, i.e. first argument in affine, second in CurveGroup coordinates.\n        pub fn mixed_add(self, p1: Point, p2: curvegroup::Point) -> curvegroup::Point {\n            let Point { x: x1, y: y1 } = p1;\n            let curvegroup::Point { x: x2, y: y2, t: t2, z: z2 } = p2;\n\n            let a = x1 * x2;\n            let b = y1 * y2;\n            let c = self.d * x1 * y1 * t2;\n            let e = (x1 + y1) * (x2 + y2) - a - b;\n            let f = z2 - c;\n            let g = z2 + c;\n            let h = b - self.a * a;\n\n            let x = e * f;\n            let y = g * h;\n            let t = e * h;\n            let z = f * g;\n\n            curvegroup::Point::new(x, y, t, z)\n        }\n\n        // Scalar multiplication with scalar represented by a bit array (little-endian convention).\n        // If k is the natural number represented by `bits`, then this computes p + ... + p k times.\n        pub fn bit_mul<let N: u32>(self, bits: [u1; N], p: Point) -> Point {\n            self.into_group().bit_mul(bits, p.into_group()).into_affine()\n        }\n\n        // Scalar multiplication (p + ... + p n times)\n        pub fn mul(self, n: Field, p: Point) -> Point {\n            self.into_group().mul(n, p.into_group()).into_affine()\n        }\n\n        // Multi-scalar multiplication (n[0]*p[0] + ... + n[N]*p[N], where * denotes scalar multiplication)\n        pub fn msm<let N: u32>(self, n: [Field; N], p: [Point; N]) -> Point {\n            let mut out = Point::zero();\n\n            for i in 0..N {\n                out = self.add(out, self.mul(n[i], p[i]));\n            }\n\n            out\n        }\n\n        // Point subtraction\n        pub fn subtract(self, p1: Point, p2: Point) -> Point {\n            self.add(p1, p2.negate())\n        }\n\n        // Conversion to equivalent Montgomery curve\n        pub fn into_montcurve(self) -> MCurve {\n            let j = 2 * (self.a + self.d) / (self.a - self.d);\n            let k = 4 / (self.a - self.d);\n            let gen_montcurve = self.gen.into_montcurve();\n\n            MCurve::new(j, k, gen_montcurve)\n        }\n\n        // Conversion to equivalent Short Weierstrass curve\n        pub fn into_swcurve(self) -> SWCurve {\n            self.into_montcurve().into_swcurve()\n        }\n\n        // Point mapping into equivalent Short Weierstrass curve\n        pub fn map_into_swcurve(self, p: Point) -> SWPoint {\n            self.into_montcurve().map_into_swcurve(p.into_montcurve())\n        }\n\n        // Point mapping from equivalent Short Weierstrass curve\n        pub fn map_from_swcurve(self, p: SWPoint) -> Point {\n            self.into_montcurve().map_from_swcurve(p).into_tecurve()\n        }\n\n        // Elligator 2 map-to-curve method (via rational map)\n        pub fn elligator2_map(self, u: Field) -> Point {\n            self.into_montcurve().elligator2_map(u).into_tecurve()\n        }\n\n        // Simplified SWU map-to-curve method (via rational map)\n        pub fn swu_map(self, z: Field, u: Field) -> Point {\n            self.into_montcurve().swu_map(z, u).into_tecurve()\n        }\n    }\n}\npub mod curvegroup {\n    // CurveGroup coordinate representation of Twisted Edwards curves\n    // Points are represented by four-dimensional projective coordinates, viz. extended Twisted Edwards coordinates.\n    // See section 3 of <https://eprint.iacr.org/2008/522.pdf> for details.\n    use crate::{\n        montcurve::curvegroup::{Curve as MCurve, Point as MPoint},\n        swcurve::curvegroup::{Curve as SWCurve, Point as SWPoint}, tecurve::affine,\n    };\n    use std::cmp::Eq;\n\n    // Curve specification\n    pub struct Curve { // Twisted Edwards curve\n        // Coefficients in defining equation a(x^2 + y^2)z^2 = z^4 + dx^2y^2\n        pub a: Field,\n        pub d: Field,\n        // Generator as point in projective coordinates\n        pub gen: Point,\n    }\n    // Point in extended twisted Edwards coordinates\n    pub struct Point {\n        pub x: Field,\n        pub y: Field,\n        pub t: Field,\n        pub z: Field,\n    }\n\n    impl Point {\n        // Point constructor\n        pub fn new(x: Field, y: Field, t: Field, z: Field) -> Self {\n            Self { x, y, t, z }\n        }\n\n        // Check if zero\n        pub fn is_zero(self) -> bool {\n            let Self { x, y, t, z } = self;\n            (x == 0) & (y == z) & (y != 0) & (t == 0)\n        }\n\n        // Conversion to affine coordinates\n        pub fn into_affine(self) -> affine::Point {\n            let Self { x, y, t: _t, z } = self;\n\n            affine::Point::new(x / z, y / z)\n        }\n\n        // Additive identity\n        pub fn zero() -> Self {\n            Point::new(0, 1, 0, 1)\n        }\n\n        // Negation\n        pub fn negate(self) -> Self {\n            let Self { x, y, t, z } = self;\n\n            Point::new(0 - x, y, 0 - t, z)\n        }\n\n        // Map into prime-order subgroup of equivalent Montgomery curve\n        pub fn into_montcurve(self) -> MPoint {\n            self.into_affine().into_montcurve().into_group()\n        }\n    }\n\n    impl Eq for Point {\n        fn eq(self, p: Self) -> bool {\n            let Self { x: x1, y: y1, t: _t1, z: z1 } = self;\n            let Self { x: x2, y: y2, t: _t2, z: z2 } = p;\n\n            (x1 * z2 == x2 * z1) & (y1 * z2 == y2 * z1)\n        }\n    }\n\n    impl Curve {\n        // Curve constructor\n        pub fn new(a: Field, d: Field, gen: Point) -> Curve {\n            // Check curve coefficients\n            assert(a * d * (a - d) != 0);\n\n            let curve = Curve { a, d, gen };\n\n            // gen should be on the curve\n            assert(curve.contains(curve.gen));\n\n            curve\n        }\n\n        // Conversion to affine coordinates\n        pub fn into_affine(self) -> affine::Curve {\n            let Curve { a, d, gen } = self;\n\n            affine::Curve { a, d, gen: gen.into_affine() }\n        }\n\n        // Membership check\n        pub fn contains(self, p: Point) -> bool {\n            let Point { x, y, t, z } = p;\n\n            (z != 0)\n                & (z * t == x * y)\n                & (z * z * (self.a * x * x + y * y) == z * z * z * z + self.d * x * x * y * y)\n        }\n\n        // Point addition\n        pub fn add(self, p1: Point, p2: Point) -> Point {\n            let Point { x: x1, y: y1, t: t1, z: z1 } = p1;\n            let Point { x: x2, y: y2, t: t2, z: z2 } = p2;\n\n            let a = x1 * x2;\n            let b = y1 * y2;\n            let c = self.d * t1 * t2;\n            let d = z1 * z2;\n            let e = (x1 + y1) * (x2 + y2) - a - b;\n            let f = d - c;\n            let g = d + c;\n            let h = b - self.a * a;\n\n            let x = e * f;\n            let y = g * h;\n            let t = e * h;\n            let z = f * g;\n\n            Point::new(x, y, t, z)\n        }\n\n        // Point doubling, cf. section 3.3\n        pub fn double(self, p: Point) -> Point {\n            let Point { x, y, t: _t, z } = p;\n\n            let a = x * x;\n            let b = y * y;\n            let c = 2 * z * z;\n            let d = self.a * a;\n            let e = (x + y) * (x + y) - a - b;\n            let g = d + b;\n            let f = g - c;\n            let h = d - b;\n\n            let x0 = e * f;\n            let y0 = g * h;\n            let t0 = e * h;\n            let z0 = f * g;\n\n            Point::new(x0, y0, t0, z0)\n        }\n\n        // Scalar multiplication with scalar represented by a bit array (little-endian convention).\n        // If k is the natural number represented by `bits`, then this computes p + ... + p k times.\n        pub fn bit_mul<let N: u32>(self, bits: [u1; N], p: Point) -> Point {\n            let mut out = Point::zero();\n\n            for i in 0..N {\n                out = self.add(\n                    self.add(out, out),\n                    if (bits[N - i - 1] == 0) {\n                        Point::zero()\n                    } else {\n                        p\n                    },\n                );\n            }\n\n            out\n        }\n\n        // Scalar multiplication (p + ... + p n times)\n        pub fn mul(self, n: Field, p: Point) -> Point {\n            // TODO: temporary workaround until issue 1354 is solved\n            let mut n_as_bits: [u1; 254] = [0; 254];\n            let tmp: [u1; 254] = n.to_le_bits();\n            for i in 0..254 {\n                n_as_bits[i] = tmp[i];\n            }\n\n            self.bit_mul(n_as_bits, p)\n        }\n\n        // Multi-scalar multiplication (n[0]*p[0] + ... + n[N]*p[N], where * denotes scalar multiplication)\n        pub fn msm<let N: u32>(self, n: [Field; N], p: [Point; N]) -> Point {\n            let mut out = Point::zero();\n\n            for i in 0..N {\n                out = self.add(out, self.mul(n[i], p[i]));\n            }\n\n            out\n        }\n\n        // Point subtraction\n        pub fn subtract(self, p1: Point, p2: Point) -> Point {\n            self.add(p1, p2.negate())\n        }\n\n        // Conversion to equivalent Montgomery curve\n        pub fn into_montcurve(self) -> MCurve {\n            self.into_affine().into_montcurve().into_group()\n        }\n\n        // Conversion to equivalent Short Weierstrass curve\n        pub fn into_swcurve(self) -> SWCurve {\n            self.into_montcurve().into_swcurve()\n        }\n\n        // Point mapping into equivalent short Weierstrass curve\n        pub fn map_into_swcurve(self, p: Point) -> SWPoint {\n            self.into_montcurve().map_into_swcurve(p.into_montcurve())\n        }\n\n        // Point mapping from equivalent short Weierstrass curve\n        pub fn map_from_swcurve(self, p: SWPoint) -> Point {\n            self.into_montcurve().map_from_swcurve(p).into_tecurve()\n        }\n\n        // Elligator 2 map-to-curve method (via rational maps)\n        pub fn elligator2_map(self, u: Field) -> Point {\n            self.into_montcurve().elligator2_map(u).into_tecurve()\n        }\n\n        // Simplified SWU map-to-curve method (via rational map)\n        pub fn swu_map(self, z: Field, u: Field) -> Point {\n            self.into_montcurve().swu_map(z, u).into_tecurve()\n        }\n    }\n}\n","path":"/home/drone/nargo/github.com/noir-lang/ec/v0.1.2/src/tecurve.nr"},"71":{"source":"use dep::std;\nuse dep::std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\nglobal NULLIFIER_DOMAIN_SEPARATOR: Field \n    = 0x100000000000000000000000000000000000000000000000000000000000000;\n\nglobal COUNTER_DOMAIN_SEPARATOR: Field \n    = 0x200000000000000000000000000000000000000000000000000000000000000;\n\n\npub fn pedersen_commitment_token(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // Use derive_generators to get different generators for G and H\n    let generators: [EmbeddedCurvePoint; 3] =\n        std::hash::derive_generators(\"PEDERSEN_COMMITMENT\".as_bytes(), 0);\n    \n    let G = generators[0];  // First generator for amount\n    let H = generators[1];  // Second generator for blinding factor\n    let D = generators[2];  // Third generator for domain separation\n     // Create scalars for multi_scalar_mul\n    let mut scalars = [EmbeddedCurveScalar { lo: 0, hi: 0 }; 3];\n    scalars[0] = from_field(m);\n    scalars[1] = from_field(r);\n    scalars[2] = from_field(token_address);\n    \n    // Create points for multi_scalar_mul: [G, H, D]\n    let mut points = [EmbeddedCurvePoint::point_at_infinity(); 3];\n    points[0] = G;\n    points[1] = H;\n    points[2] = D;  \n    \n    // Compute commitment: m*G + r*H + token_address*D\n    multi_scalar_mul(points, scalars)\n}\n\npub fn pedersen_commitment_non_hiding(m: Field, token_address: Field) -> EmbeddedCurvePoint {\n    let generators: [EmbeddedCurvePoint; 3] =\n        std::hash::derive_generators(\"PEDERSEN_COMMITMENT_PERSONAL\".as_bytes(), 0);\n    \n    let G = generators[0];  // \n    let D = generators[1];  // \n     // Create scalars for multi_scalar_mul\n    let mut scalars = [EmbeddedCurveScalar { lo: 0, hi: 0 }; 2];\n    scalars[0] = from_field(m);\n    scalars[1] = from_field(token_address);\n    \n    // Create points for multi_scalar_mul: [G, H, D]\n    let mut points = [EmbeddedCurvePoint::point_at_infinity(); 2];\n    points[0] = G;\n    points[1] = D;\n    \n    // Compute commitment: m*G + r*H + token_address*D\n    multi_scalar_mul(points, scalars)\n}\n\n\n\npub fn to_negative_domain(token_address: Field) -> Field {\n    token_address + NULLIFIER_DOMAIN_SEPARATOR\n}\n\npub fn to_nullifier_domain(token_address: Field) -> Field {\n    token_address + NULLIFIER_DOMAIN_SEPARATOR\n}\n\n\n\n// === DOMAIN SEPARATION FOR negative/positive ===\n// Creates distinct commitment spaces for the same token\n\npub fn pedersen_commitment_negative(m: Field, r: Field, token_address: Field, mult: Field) -> EmbeddedCurvePoint {\n    // negative space: add 1 to the most significant bit\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    // becomes 0x10000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    let negative_domain = token_address + NULLIFIER_DOMAIN_SEPARATOR;\n    pedersen_commitment_token(m, r, negative_domain * mult)\n}\n\npub fn pedersen_commitment_counter(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // negative space: add 1 to the most significant bit\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    // becomes 0x20000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    let counter_domain = token_address + COUNTER_DOMAIN_SEPARATOR;\n    pedersen_commitment_token(m, r, counter_domain)\n}\n\n\npub fn pedersen_commitment_positive(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // positive space: token_address (original)\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    pedersen_commitment_token(m, r, token_address)\n}\n\n// === COMMITMENT VERIFICATION ===\n\npub fn verify_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field) -> bool {\n    let computed_commitment = pedersen_commitment_token(m, r, token_address);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\npub fn verify_negative_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field, mult: Field) -> bool {\n    let computed_commitment = pedersen_commitment_negative(m, r, token_address, mult);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\npub fn verify_positive_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field) -> bool {\n    let computed_commitment = pedersen_commitment_positive(m, r, token_address);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\n// === COMMITMENT ARITHMETIC ===\n\npub fn add_commitments(c1: EmbeddedCurvePoint, c2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    c1 + c2\n}\n\npub fn add_multiple_commitments(commitments: [EmbeddedCurvePoint]) -> EmbeddedCurvePoint {\n    let mut result = EmbeddedCurvePoint::point_at_infinity();\n    \n    for i in 0..commitments.len() {\n        if i == 0 {\n            result = commitments[i];\n        } else {\n            result = result + commitments[i];\n        }\n    }\n    \n    result\n}\n\npub fn subtract_commitments(c1: EmbeddedCurvePoint, c2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // c1 - c2 = c1 + (-c2)\n    let neg_c2 = -c2;\n    c1 + neg_c2\n}\n\n\n// === BALANCE VERIFICATION ===\n// Proves that negative commitments >= positive commitments\n\npub fn verify_balance_proof(\n    negative_commitment: EmbeddedCurvePoint,\n    positive_commitment: EmbeddedCurvePoint,\n    total_commitment: EmbeddedCurvePoint,\n    negative_m: Field,\n    negative_r: Field,\n    positive_m: Field,\n    positive_r: Field,\n    token_address: Field\n) -> bool {\n    // Verify commitment openings\n    let negative_valid = verify_negative_commitment_opening(negative_commitment, negative_m, negative_r, token_address, 1);\n    let positive_valid = verify_positive_commitment_opening(positive_commitment, positive_m, positive_r, token_address);\n    \n    // Verify arithmetic: negative + positive = total\n    let sum_commitment = add_commitments(negative_commitment, positive_commitment);\n    let x_equal = sum_commitment.x == total_commitment.x;\n    let y_equal = sum_commitment.y == total_commitment.y;\n    let arithmetic_valid = x_equal & y_equal;\n    \n    // Verify sufficient balance: negative_m >= positive_m\n    let balance_valid = (negative_m as u128) >= (positive_m as u128);\n    \n    ((negative_valid as u1) & (positive_valid as u1) & (arithmetic_valid as u1) & (balance_valid as u1)) as bool\n}\n\n// === UTILITY FUNCTIONS ===\n\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\nfn from_field(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = compute_decomposition(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/pedersen-commitments/src/pedersen_commitments.nr"},"79":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon/src/poseidon2.nr"},"81":{"source":"use dep::std;\r\nuse dep::poseidon::poseidon2::Poseidon2;\r\n\r\n/// Poseidon CTR Mode Encryption Library\r\n/// \r\n/// This library provides Poseidon-based encryption in CTR mode for field elements.\r\n/// It includes functions for encrypting individual fields and batch encryption.\r\n\r\n/// Generate a keystream using Poseidon with key and nonce\r\npub fn poseidon_keystream(key: Field, nonce: u32) -> Field {\r\n    // === POSEIDON KEYSTREAM GENERATION ===\r\n    // Generate keystream using Poseidon with key and nonce\r\n    \r\n    // Use the public hash function with key and nonce\r\n    Poseidon2::hash([key, nonce as Field], 2)\r\n}\r\n\r\n/// Encrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_encrypt(plaintext: Field, key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE ENCRYPTION ===\r\n    // Use Poseidon to generate keystream for CTR mode encryption\r\n    \r\n    // Generate keystream using Poseidon with key and counter\r\n    let keystream = poseidon_keystream(key, counter);\r\n    \r\n    // Encrypt by adding keystream to plaintext (field arithmetic equivalent of XOR)\r\n    let ciphertext = plaintext + keystream;\r\n    \r\n    ciphertext\r\n}\r\n\r\n/// Decrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_decrypt(ciphertext: Field, key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE DECRYPTION ===\r\n    // Decryption is the same as encryption in CTR mode\r\n    \r\n    // Generate the same keystream\r\n    let keystream = poseidon_keystream(key, counter);\r\n    \r\n    // Decrypt by subtracting keystream from ciphertext\r\n    let plaintext = ciphertext - keystream;\r\n    \r\n    plaintext\r\n}\r\n\r\n/// Encrypt all four fields (amount, token_address, ref, encryption_key) in one function call\r\n/// This provides integrity checking - the ref value can be verified when absorbing the note\r\npub fn poseidon_encrypt_all_fields(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> (Field, Field, Field, Field) {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ===\r\n    // Encrypt all four fields with different counters in one function call\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    let encrypted_key = poseidon_ctr_encrypt(encryption_key, encryption_key, 3);\r\n    \r\n    (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n/// Encrypt all four fields and return as array for cleaner API\r\npub fn poseidon_encrypt_all_fields_array(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> [Field; 3] {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ARRAY ===\r\n    // Encrypt all four fields and return the first 3 as an array\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    \r\n    [encrypted_amount, encrypted_token_address, encrypted_ref]\r\n}\r\n\r\n// ===== BASIC FUNCTIONALITY TESTS =====\r\n\r\n#[test]\r\nfn test_basic_encryption_decryption() {\r\n    // Test basic encryption and decryption round-trip\r\n    let plaintext = 12345 as Field;\r\n    let key = Poseidon2::hash([42 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_zero_plaintext() {\r\n    // Test encryption of zero value\r\n    let plaintext = 0 as Field;\r\n    let key = Poseidon2::hash([123 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_large_plaintext() {\r\n    // Test encryption of large field value (using a large but valid field value)\r\n    let plaintext = 21888242871839275222246405745257275088548364400416034343698204186575808495616 as Field; // p-1\r\n    let key = Poseidon2::hash([456 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n// ===== COUNTER/KEYSTREAM TESTS =====\r\n\r\n#[test]\r\nfn test_different_counters_produce_different_ciphertexts() {\r\n    // Test that different counters produce different ciphertexts\r\n    let plaintext = 1000 as Field;\r\n    let key = Poseidon2::hash([789 as Field], 1);\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, key, 0);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, key, 1);\r\n    let ciphertext3 = poseidon_ctr_encrypt(plaintext, key, 2);\r\n    \r\n    // All ciphertexts should be different\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n    \r\n    // But all should decrypt to the same plaintext\r\n    assert(poseidon_ctr_decrypt(ciphertext1, key, 0) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext2, key, 1) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext3, key, 2) == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_consistency() {\r\n    // Test that same inputs produce same keystream\r\n    let key = Poseidon2::hash([999 as Field], 1);\r\n    let nonce = 5 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(key, nonce);\r\n    let keystream2 = poseidon_keystream(key, nonce);\r\n    \r\n    assert(keystream1 == keystream2);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_nonces() {\r\n    // Test that different nonces produce different keystreams\r\n    let key = Poseidon2::hash([111 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(key, 0);\r\n    let keystream2 = poseidon_keystream(key, 1);\r\n    let keystream3 = poseidon_keystream(key, 2);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_keys() {\r\n    // Test that different keys produce different keystreams\r\n    let nonce = 0 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(Poseidon2::hash([1 as Field], 1), nonce);\r\n    let keystream2 = poseidon_keystream(Poseidon2::hash([2 as Field], 1), nonce);\r\n    let keystream3 = poseidon_keystream(Poseidon2::hash([3 as Field], 1), nonce);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n// ===== BATCH ENCRYPTION TESTS =====\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_basic() {\r\n    // Test batch encryption of all four fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Verify each field can be decrypted individually\r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_zero_values() {\r\n    // Test batch encryption with zero values\r\n    let amount = 0 as Field;\r\n    let token_address = 0 as Field;\r\n    let ref = 0 as Field;\r\n    let encryption_key = Poseidon2::hash([0 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_different_keys() {\r\n    // Test that different encryption keys produce different results\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    \r\n    let key1 = Poseidon2::hash([111 as Field], 1);\r\n    let key2 = Poseidon2::hash([222 as Field], 1);\r\n    \r\n    let (enc1_amount, enc1_token, enc1_ref, enc1_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key1\r\n    );\r\n    \r\n    let (enc2_amount, enc2_token, enc2_ref, enc2_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key2\r\n    );\r\n    \r\n    // Different keys should produce different ciphertexts\r\n    assert(enc1_amount != enc2_amount);\r\n    assert(enc1_token != enc2_token);\r\n    assert(enc1_ref != enc2_ref);\r\n    assert(enc1_key != enc2_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_integrity_check() {\r\n    // Test that the ref and key values provide integrity checking\r\n    let amount = 5000 as Field;\r\n    let token_address = 6000 as Field;\r\n    let ref = 7000 as Field;\r\n    let encryption_key = Poseidon2::hash([777 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Decrypt the ref and key values - they should match the original values\r\n    let decrypted_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n    // This provides integrity: if someone tries to use a different key to decrypt,\r\n    // the values won't match, indicating tampering\r\n    let wrong_key = Poseidon2::hash([888 as Field], 1);\r\n    let wrong_decrypted_ref = poseidon_ctr_decrypt(enc_ref, wrong_key, 2);\r\n    let wrong_decrypted_key = poseidon_ctr_decrypt(enc_key, wrong_key, 3);\r\n    assert(wrong_decrypted_ref != ref);\r\n    assert(wrong_decrypted_key != encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_array() {\r\n    // Test the array version of encrypt all fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let encrypted_array = poseidon_encrypt_all_fields_array(amount, token_address, ref, encryption_key);\r\n    \r\n    // Verify array has 3 elements\r\n    assert(encrypted_array.len() == 3);\r\n    \r\n    // Verify each element can be decrypted\r\n    let dec_amount = poseidon_ctr_decrypt(encrypted_array[0], encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(encrypted_array[1], encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(encrypted_array[2], encryption_key, 2);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n}\r\n\r\n// ===== SECURITY TESTS =====\r\n\r\n#[test]\r\nfn test_wrong_key_fails_decryption() {\r\n    // Test that decryption with wrong key fails\r\n    let plaintext = 5000 as Field;\r\n    let correct_key = Poseidon2::hash([111 as Field], 1);\r\n    let wrong_key = Poseidon2::hash([222 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, correct_key, counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, wrong_key, counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_wrong_counter_fails_decryption() {\r\n    // Test that decryption with wrong counter fails\r\n    let plaintext = 7777 as Field;\r\n    let key = Poseidon2::hash([333 as Field], 1);\r\n    let correct_counter = 2 as u32;\r\n    let wrong_counter = 3 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, correct_counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, key, wrong_counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_deterministic() {\r\n    // Test that same inputs always produce same ciphertext\r\n    let plaintext = 8888 as Field;\r\n    let key = Poseidon2::hash([444 as Field], 1);\r\n    let counter = 1 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    \r\n    // Same inputs should produce same ciphertext\r\n    assert(ciphertext1 == ciphertext2);\r\n}\r\n\r\n#[test]\r\nfn test_different_plaintexts_different_ciphertexts() {\r\n    // Test that different plaintexts produce different ciphertexts\r\n    let key = Poseidon2::hash([555 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(1000 as Field, key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(2000 as Field, key, counter);\r\n    let ciphertext3 = poseidon_ctr_encrypt(3000 as Field, key, counter);\r\n    \r\n    // Different plaintexts should produce different ciphertexts\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n}\r\n\r\n// ===== EDGE CASE TESTS =====\r\n\r\n#[test]\r\nfn test_max_counter_value() {\r\n    // Test with maximum counter value\r\n    let plaintext = 1234 as Field;\r\n    let key = Poseidon2::hash([666 as Field], 1);\r\n    let max_counter = 4294967295 as u32; // u32::MAX\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, max_counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, max_counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_preserves_field_arithmetic() {\r\n    // Test that encryption preserves field arithmetic properties\r\n    let a = 1000 as Field;\r\n    let b = 2000 as Field;\r\n    let key = Poseidon2::hash([777 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    // Encrypt individual values\r\n    let enc_a = poseidon_ctr_encrypt(a, key, counter);\r\n    let enc_b = poseidon_ctr_encrypt(b, key, counter);\r\n    \r\n    // Decrypt and verify\r\n    let dec_a = poseidon_ctr_decrypt(enc_a, key, counter);\r\n    let dec_b = poseidon_ctr_decrypt(enc_b, key, counter);\r\n    \r\n    assert(dec_a == a);\r\n    assert(dec_b == b);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_uniformity() {\r\n    // Test that keystreams appear uniformly distributed\r\n    let key = Poseidon2::hash([888 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(key, 0);\r\n    let keystream2 = poseidon_keystream(key, 1);\r\n    let keystream3 = poseidon_keystream(key, 2);\r\n    let keystream4 = poseidon_keystream(key, 3);\r\n    let keystream5 = poseidon_keystream(key, 4);\r\n    \r\n    // All keystreams should be different (very high probability)\r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream3 != keystream4);\r\n    assert(keystream4 != keystream5);\r\n    assert(keystream1 != keystream3);\r\n    assert(keystream1 != keystream4);\r\n    assert(keystream1 != keystream5);\r\n    assert(keystream2 != keystream4);\r\n    assert(keystream2 != keystream5);\r\n    assert(keystream3 != keystream5);\r\n}\r\n\r\n// ===== TEST FOR TYPESCRIPT COMPARISON =====\r\n\r\n/// Get test values for TypeScript comparison\r\npub fn get_poseidon_ctr_test_values() -> (Field, Field, Field, Field, Field, Field, Field, Field) {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Return all values for external testing\r\n    (amount, token_address, ref, encryption_key, encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n#[test]\r\nfn test_poseidon_ctr_encryption_values() {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Decrypt all fields\r\n    let decrypted_amount = poseidon_ctr_decrypt(encrypted_amount, encryption_key, 0);\r\n    let decrypted_token_address = poseidon_ctr_decrypt(encrypted_token_address, encryption_key, 1);\r\n    let decrypted_ref = poseidon_ctr_decrypt(encrypted_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(encrypted_key, encryption_key, 3);\r\n    \r\n    // Verify round-trip encryption/decryption\r\n    assert(decrypted_amount == amount);\r\n    assert(decrypted_token_address == token_address);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n \r\n    println(\"Encrypted amount: 0x{:x}\");\r\n    println(encrypted_amount);\r\n    println(\"Encrypted token address: 0x{:x}\");\r\n    println(encrypted_token_address);\r\n    println(\"Encrypted ref: 0x{:x}\");\r\n    println(encrypted_ref);\r\n    println(\"Encrypted key: 0x{:x}\");\r\n    println(encrypted_key);\r\n    println(\"Decrypted amount: 0x{:x}\");\r\n    println(decrypted_amount);\r\n    println(\"Decrypted token address: 0x{:x}\");\r\n    println(decrypted_token_address);\r\n    println(\"Decrypted ref: 0x{:x}\");\r\n    println(decrypted_ref);\r\n    println(\"Decrypted key: 0x{:x}\");\r\n    println(decrypted_key);\r\n}\r\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon-ctr-encryption/src/lib.nr"}},"names":["main"],"brillig_names":["field_less_than","decompose_hint","lte_hint","directive_invert","directive_integer_quotient","directive_to_radix"]}