{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":15088041602871335369,"abi":{"parameters":[{"name":"user_key","type":{"kind":"field"},"visibility":"private"},{"name":"token_address","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"array","length":2,"type":{"kind":"field"}},{"kind":"array","length":2,"type":{"kind":"field"}},{"kind":"array","length":2,"type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1daZsdRRU+k4QlyagEEjVqVDYJIKS23kASGHYkgEAggCDdXd2IsokIgohEREHWSCASQDZBRQUVVPCryxc/IPwfeawi3VDTs9y56fdc7xDqeSpd033nnXPec+qc6lMzlQna3d52/d80s0001xObqxaxMVWiKqllLlRWpJEwURGnMpVRGlmVal2lJk2yIktEJo2uZB1luha724oAS/RsnHKu3HM5ZfeGl+1A15d1ZH2nGa+YY7yyGbffN+n6R1z/qOsfC+5zcXDAnnOgFsLB5AI4OKDDwaoG5yDXVzf3Z8NeEmBMLhB7jesfd/0Trn9yHuyJPcBe6/qnXP+065+ZB3vFHmCvc/2zrn/O9c8399tnS2hm6/qJ6NfkGuKZ0zScnHIQdsjFwc31kJaQpc3VP7ijc89/aFtHqCUd4fpOtkOAWIcunDRRD2ghD4fOwsPS4Yw0qE1zpgE8lAN4kAcz2Uf0bO3kn6CZDR3EDx5C7kE/K5T3ME6BPXh3gvUV/jCcAeXhQH25ODycho/0g37u4YSN9Gi9D2n0HtZ3BuEi7f0FIIdhcPa4PjiPMvOvpcWX+Y9orutbQloC/YNu5l9P/Jl/PRDrSOLJ/EcSf+ZfS7jMfwSTfUTPNsrMfwTxZP6jOAX24OjMfxTOgPJoGu/M7zk8mvCZ/2ga78y/vtEbnfmR9v4i8WR+jzsoOEutXZa0iaxtraMkU4WMdRzXpk7i1Ng6MrlNKmlyrbIqEbVMqyqJdJnEdWbLuA5fy6TV2tisKGWk4rwQqdW5qE2ilcitTqzVaRznWts4rdMsVSqvdSqiJMlErHSmkK+6xxDPCgTN31ogf8gFw7Fgn9zf9X0DHt/DjgtRl6oujHEaOX2tySrHT2a0KFNV6kpIm+W6jm0hrKqUKdIqKaM6tTLNsvKdrj1EXtelVG4CO22V1JWWUV7aTMZFLnViYlPkphZ1rpS1teMnsZmyQiWODvfNXTzRs82It3VUyjx1Ns4z40RJTVzbVNkklkVVOcmrrKhiobTMoqQuqqKMTJyYNFIm06qouvKpuCqETFQSpSpz3mCMjPNcSWdmlReFipzTVe5pmThlRWlq52FlKk1Rp0mZRAmHvmHd0s/ptj55TDBeH4yPbcYb/M/3NqTRvq1I4okVhJVThVyo5qpbQtqg7x/8t3NP08yVJXqVHpK4p8Gnat4wFOECmcbpONJVesiBTLVyAcp/LrVCuhmsXPS3hRGlyEtVZUZmtVFGl7YsHGYufYArszrdjRXKazgF9uDdlVZf4Q3QSSOgvlwcRrPg9uUwImyEQ+ut59C7L25M2MzWBtS48fNRZqlJGossNVRNLWmuaUtIS6B/0K2p+Q9x19RSIFa2cNKGqqllxF9Tm1w4DwNragmTfUTPNspsnQwh9zA1teM4Bfbg6JracTgDyuNpvLO15/B4wtfUjqfxztZpoze6poa095eIJ/N7XO6aWhic+9aEkAnvBDCnH9aEGry9rCY0W+2nXQC24xOa8UbXNzWyjHK1fSJhY3C3gbCn1YROaq5TLSFt0PIPujWhKeKvCYUk9q0JnUS4QDaF03Gkq8yQA2RN6GROgT04uiZ0MtBJTwHqy8XhKYSvCZ1C2AiH1ntqDr374p5K2MzWBtRTafQ1oXU0FllqqJrQac319JaQlkD/oFsT8h/irgmdDsQ6Y+GkDVUTOoP4a0LrFs7DwJrQaUz2ET3bKLP1aUPIPUxN6ExOgT04uiZ0Js6A8iwa72ztOTyL8DWhs2i8s/Xpjd7omhDS3l8mnszvcX1wHmXmnwixBubf+dss4rJk/rOb6+aWkJZA/6Cb+TcTf+bfDMQ6h3gy/znEn/knCJf5z2ayT18nH2XmP5t4Mv+5nAJ7cHTmP5dwTnoejXfm9xyeR/jMfx6Nd+bf3OiNzvxIe3+FeDK/x+XeDQpfy/ruBiFfdc8H+yUXfxNA/pALhguG4W9A8vtwN23v3U3zc7rdNTs/GG8Oxhc04wtd3+L6RTTat5WLiCdWEFbOabtpFzfXrS0hbdD3D7q7aVuJfzctJLHvbtrFhAtkW3E6jnSVHnKA3E27hFNgD47eTbsE6KSXAvXl4vBSwu+mXUrYCIfWe+scevfFvYywma0NqJfRzMyEDqgbgDxsBGJ9lf4/AVX0axIpdyjv5ZwCX86AewXxBkHRr72r9xUBwSDceV/jRL8mBZDTTUCsr9HinKxIuUN5r+QU+EoG3JzGe7J6vfOAYBAu62TdQOMZTAvCOv3yxt4et33XFsH4Cnp/Qm8M7m8KxlPNtXTdul41X7fYG+bA1gH2oM/Url/l+tcb3TkSXk741eXVhPV3tHxcen8DaBsKGnoDVQOxvgnWedj9iEGYfn4i7eLn5NUMvnMNYecMmkcL5vEqJh6vJZ5ci56DU0Cs68Z8Dvp4sxGI52PONQy+cz2N9xz0PG4C83gtA4830OLI/2j7INe832LmUPRr7/rOdQy2uXHM9fZ2uZFB72+Pud4+9kwx6H3TmOu9gUnvv4+53n5uX8+g9z/AerdtGVjOC4FY3wHaBeg3EmmLURZBgXxOK4LezCnwzQy4twCdlEvvWwKCQbgssnpQjkD/zzHX2wf6Gxj0/hctjkC/BYj1XaBdgH4jkbYYZaAH8jkt0N/KKfCtDLi30XgHeq/3bQHBINx5J77o16DJ83v0wV/hhbbo7jz25e92+uAHznB30PtLu9t3ezC+hd4PrhcG97cE4/aXVr9Pu//87gc0vaFtc+de4tscFZ2bCL9LD6wUyZuA+m4jnrly5xxzZVswVwZ95oeu3+X6jxr5OF7EbmPwobtpvH2cS+8fA21DQUPv4m0DYv0ErDN6d8PnG6Rd/Jy8m8F37iHsnEHzeAeYx7uYeLwXzCPXHNwKxPrpmM9BvyYE5lnpY849DL5zH433HNzCwOO9DDzeD+Rxtr8cRPPq5+KdQDw/H+8L5EVxQbO0BWIPdXbKA831QaLpf3noH3TPTnmQ+M9OeRCI9dDCSRvq7JSHAh7QC/XWQdET9U3COida73YiofX+D/FMyiGr/APPt3mAaQ6Jfk0C/UYibTHKv+h9YAi5hzl352FOgT34sNlz0M99GOgM24H6cnG4nfDn7mwn3kCMCB7bCX/uDtLePwNyGCZ2j+sT+6hWoshdBZ9A7w/kBeGObCX6SHPdQTR91ekfdFeiO4h/JboDiPXowkkbaiX6KPGuRG8nfIB5i3gDoOjX3ptIaL3fJp5JiV6JPsI0h0S/JoF+I5G2GOVK9BHCLURCeR/jFNiDo1eijwGdYSdQXy4OdxJ+JbqTeAMxInjsJPxKFGnvnwM5DBO7x51rJdo2dOJbRTwJioaTc6hV4+PNdVdLSEugf9BdNe4i/lXjLiDWEwsnbahV4xPEf/bzKsKtSB5nso/o2UaZ+R8nnsz/JKfAHhyd+Z/EGVA+ReOd+T2HTxE+8z9F4535dzV6ozM/0t6/IJ7M73G7wbn7itf3vGHkJtvToVw9z1R+E4g1qo2fvrZAlpmeAfL3FhCLq/SBPtN7FdCuyIXgs4SNNf5M7+UBjy22imItpI7rSpaxLIs6r90gL4soq6x1RFX+9GkrbKmNlFrlce7VLkWS5HVh6hlnUldFlZRplJg0i6tI5mVkpTQiT0ylrSkLm6tC67Q0lcqzWlayyowtc5XmsUgMyxnX0/WtbJmZIipMkRa2ELGQaRbZxDpZRea8Q0SyMnnljK2TQulC1UkkRZo5s0ttZ5xhntraKuusarVKVOSo9J4hnN51oRPnm0brqK7zOBEqz22VFrFJbFGJQtuykuxnmKtCFKZyQiW6llEkrcnqKKlUVERpotKsdMOyjurYyESpqpQ2rXNjTBZVdZ3OkE9mXrOssDIuM1s55eOyNDp15pTi3ePSk6qMkywxZaqLSJXGmdbEVjj+lLSKQ9/2rPr2F1ba37R+OhjvCMbPBONdwfjZZvyc68+7/kua3tBrnhf2iIckjrPYBR33bxUnznCF+yrzsh1I089zfyHQbTIYrwjGBzTj9vtedP1Xrv/a9d8092fDfnEOvPmwX3L9t67/zvXfB/e5+H2ZYH6mZ+PgpUDXlxfIwSuu/8H1P7r+pxFw8CqOAzOIg1cXyMFrrv/Z9b+4/ld638c+/H8nGry96P+dAOLCc+l8OeJ1199w/W80vQ37/jpIp6WEiwVc1V60zsuAOj+3SHTeB6jz84tE532BOr++SHTeD6jzG0w67wPWeX+gzmuAWGuBWOuAWK+MyK595ZwA+shyoFyTY+ojrwVYqu6FJcM1VLi5syS458f7NV8vbT7vfWDf5n63JtR+7/7NtX22IsBcirO5avFX8uCL/WhmWxGMV3aetfovm+X7Jub4eknnOt9n59s0/Mgsz1rMg5prKG+rx/LOdU2AC+RStvirefBntdWaYLy6o2fI94kgGVq8tsa8D81sSzrP2s9258wEXj7ZlWXpLD+rba3PrA7utXz+DzBFsYGStQAA","debug_symbols":"7Z3bTiM5EED/Jc88uMp1sfmV1WoUIIwiRQnistIKzb9vg2KTnTRtzdDqqcK80aTanOOku8qO2zyvbjZXT9+/bfe3h4fV5V/Pq93hev24PeyHo+dVeP3Vw916/3L08Li+f1xdKvHFarO/GX5S/nGxut3uNqtLgR8XZ6GR8RhKIDU0pZFQVJBjLGoM08GgGo/BoBkbwQELBQTh0+C/L1bw+RXx8yvGMcUU6HhGInGvSJ9fkUcVNR/PyIjuFWVMMTPXM4L/i1HHHIe4AgMA/t/INCqJkMopmBrvJChDhRF6az+MBCvEAjMIw3Sw5IohGfU0eCDPbskh+EUHv+joFz36RSe/6OwXXfyiq190v8kU5simqRYlKaTF0DH4RQe/6OgXPfpFJ7/o7Bdd/KKrX/TkF91vNo0fz6YYopapjKBhmiaqlOCYINbgYb7khQZM0aApmrgwTcqlNI35nIZM0bApGjFFo6ZokimabImGgikaMEUzfi+OUP4AxEQ2UyxFv+jkF539ootfdPWLnvyiZ7foHPyig190v9mUP55NZxyUMZmi4YVpJks2FlM0aoommaLJlmgkmKIBUzRoiiaaohm/F1NdaAWUsJXU/szXscJ+0cUvuvpFT37Rs1t0DX7RwS86+kWPftH9ZlOdI5v+mdGtil909Yue/KJnt+gp+EUHv+joFz36RSe/6H6zafp4Np1xdjapKZpkiiYvTDM5k5SDKRowRYOmaKIpGjJFw6ZoxBSNmqIZvxdzfYQcRPI0DUMo6AyYp2kgUCgtB4VTmrGWc3lYnxHoZ/TsFh1CcMwOjtnRMjtSbRlFztijY3ZyzM6O2cUyu2jJTKz/v1ZHxmYSC4ZKimei2ouo6YSdoIomxo+Jmk7vvyaaS7mmCvCzKJiuBeYUXXw9C8U67mc9w0FbOIuvaBGsOHqWOWbYTWPW3mFbOIs/ZzX9ZlnOfgJ1yzUBSWfslhNai91yjhLIZZM0wfOPMFpOOy12x0NQND0EbbCbHoI22Mkxu+khaIPd9BC0wW56VDk99EfTA8UGu+mx3zR7ND2ca7CbzqsNdsdTu9F0Xp1x9iqaTsJziprO2HOKmk7vM85HRtO1wJyivcwwx15mmKmXGWZafL3S5CwhoS2cxVcsTU5akuVaoDHxR5bTe4vdcsZusY8nYQ113l21+Z8SqH4qOTVWBGcunlkamrPuZJ760MxdaL6z0cyn04Q+NLEPzdiHJvWhyX1oSh+afVRB3EcVxH1UQbJ0FZRqwyHAgp7QiSd24hk78aROPLkTT+nEUzvxTJ145j48tZN6SDuph7STekgXrocg4NvXB8QLilIvotyLqPQiqr2Ipl5EcyeiKfQiCr2IYi+ivVRGaenKCOvTYINFI3h6ty9I7JhdHLOrY/Z3qoxc2RNJi72gE7yFvkichaLWBXmoMUwHD71W9zfUjI3ggFhvGMKnwa+auQvN8S32kLAsPEM6uT/61RytL5BDyRnIJ0tERzVPvik8udzy2BXE9YkCAZwOddF5+NV5v995cbzzcsURjl+d907n0Vfn/X7njRZ3ONSwFYcanTfbzrLDwdX9drfbfv+2O1yvH7eH/cNw6vDrf9b32/XVbnM8vH3aX5+8+vjvXXmlnH93f7je3Dzdb15aen1taP4/","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"61":{"source":"use dep::std;\nuse dep::poseidon::poseidon2::Poseidon2;\nuse dep::poseidon_ctr_encryption::{poseidon_ctr_encrypt};\nuse dep::ec::tecurve::affine::{Curve, Point};\nuse dep::ec::consts::te::{baby_jubjub};\nuse dep::pedersen_commitments::pedersen_commitments::{\n    pedersen_commitment_positive,\n    pedersen_commitment_negative,\n    pedersen_commitment_counter,\n    add_multiple_commitments,\n    to_nullifier_domain,\n    pedersen_commitment_non_hiding\n};\nuse dep::keccak::keccak256;\nmod test;\n\nglobal VIEW_STRING: Field = 0x76696577696e675f6b6579 as Field;\n\npub fn main(\n    user_key: Field,\n    token_address: pub Field,\n    amount: pub Field\n) -> pub (Field, [Field; 2], [Field; 2], [Field; 2]) {\n\n    let nonce = 0 as Field;\n    let user_key_hash = Poseidon2::hash([user_key], 1);\n    let nonce_commitment = Poseidon2::hash([user_key_hash, nonce], 2);\n    \n \n    let amount_hashed = Poseidon2::hash([amount, user_key_hash], 2);\n    let token_address_hashed = Poseidon2::hash([token_address, user_key_hash], 2);\n    let nullifier = 0 as Field;\n    let nullifier_hashed = Poseidon2::hash([nullifier, user_key_hash], 2);\n    let nullifier_domain = to_nullifier_domain(token_address);\n    \n    \n    let c_balance_commitment = pedersen_commitment_non_hiding(amount_hashed, token_address_hashed);\n    let c_token_initializer = pedersen_commitment_non_hiding(token_address_hashed, user_key_hash);\n    let c_inbound_nullifier = pedersen_commitment_non_hiding(nullifier_hashed, nullifier_domain);\n    let c_notes_blinder = pedersen_commitment_non_hiding(user_key_hash, 0x46);\n    let c_tot = add_multiple_commitments([c_balance_commitment, c_token_initializer, c_inbound_nullifier]);\n    \n    let main_stack_commitment = pedersen_commitment_positive(c_tot.x, c_tot.y, nonce_commitment);\n    \n    let view_key = Poseidon2::hash([VIEW_STRING, user_key_hash], 2);\n    \n    // Calculate opening values for personal_c_tot commitment (c_tot)\n    // c_tot = c_balance_commitment + c_token_initializer + c_inbound_nullifier\n    // Opening values: m_total = amount_hashed + token_address_hashed + nullifier_hashed\n    //                 r_total = token_address_hashed + user_key_hash + nullifier_domain\n    let personal_c_tot_m = amount_hashed + token_address_hashed + nullifier_hashed;\n    let personal_c_tot_r = token_address_hashed + user_key_hash + nullifier_domain;\n    \n    // Encrypt opening values using view_key\n    let encryption_key = Poseidon2::hash([view_key, nonce], 2);\n    let encrypted_personal_c_tot_m = poseidon_ctr_encrypt(personal_c_tot_m, encryption_key, 3);\n    let encrypted_personal_c_tot_r = poseidon_ctr_encrypt(personal_c_tot_r, encryption_key, 4);\n    \n    let nonce_discovery_entry = pedersen_commitment_non_hiding(1, nonce_commitment);\n    (        \n        nonce_commitment,                      \n        [main_stack_commitment.x, main_stack_commitment.y],\n        [nonce_discovery_entry.x, nonce_discovery_entry.y],\n        [encrypted_personal_c_tot_m, encrypted_personal_c_tot_r]\n    )\n}\n\n\n\n\n\n","path":"/home/drone/projects/ethrome25/circuits/main/nydus-entry/src/main.nr"},"80":{"source":"use dep::std;\nuse dep::std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\nglobal NULLIFIER_DOMAIN_SEPARATOR: Field \n    = 0x100000000000000000000000000000000000000000000000000000000000000;\n\nglobal COUNTER_DOMAIN_SEPARATOR: Field \n    = 0x200000000000000000000000000000000000000000000000000000000000000;\n\n\npub fn pedersen_commitment_token(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // Use derive_generators to get different generators for G and H\n    let generators: [EmbeddedCurvePoint; 3] =\n        std::hash::derive_generators(\"PEDERSEN_COMMITMENT\".as_bytes(), 0);\n    \n    let G = generators[0];  // First generator for amount\n    let H = generators[1];  // Second generator for blinding factor\n    let D = generators[2];  // Third generator for domain separation\n     // Create scalars for multi_scalar_mul\n    let mut scalars = [EmbeddedCurveScalar { lo: 0, hi: 0 }; 3];\n    scalars[0] = from_field(m);\n    scalars[1] = from_field(r);\n    scalars[2] = from_field(token_address);\n    \n    // Create points for multi_scalar_mul: [G, H, D]\n    let mut points = [EmbeddedCurvePoint::point_at_infinity(); 3];\n    points[0] = G;\n    points[1] = H;\n    points[2] = D;  \n    \n    // Compute commitment: m*G + r*H + token_address*D\n    multi_scalar_mul(points, scalars)\n}\n\npub fn pedersen_commitment_non_hiding(m: Field, token_address: Field) -> EmbeddedCurvePoint {\n    let generators: [EmbeddedCurvePoint; 3] =\n        std::hash::derive_generators(\"PEDERSEN_COMMITMENT_PERSONAL\".as_bytes(), 0);\n    \n    let G = generators[0];  // \n    let D = generators[1];  // \n     // Create scalars for multi_scalar_mul\n    let mut scalars = [EmbeddedCurveScalar { lo: 0, hi: 0 }; 2];\n    scalars[0] = from_field(m);\n    scalars[1] = from_field(token_address);\n    \n    // Create points for multi_scalar_mul: [G, H, D]\n    let mut points = [EmbeddedCurvePoint::point_at_infinity(); 2];\n    points[0] = G;\n    points[1] = D;\n    \n    // Compute commitment: m*G + r*H + token_address*D\n    multi_scalar_mul(points, scalars)\n}\n\n\n\npub fn to_negative_domain(token_address: Field) -> Field {\n    token_address + NULLIFIER_DOMAIN_SEPARATOR\n}\n\npub fn to_nullifier_domain(token_address: Field) -> Field {\n    token_address + NULLIFIER_DOMAIN_SEPARATOR\n}\n\n\n\n// === DOMAIN SEPARATION FOR negative/positive ===\n// Creates distinct commitment spaces for the same token\n\npub fn pedersen_commitment_negative(m: Field, r: Field, token_address: Field, mult: Field) -> EmbeddedCurvePoint {\n    // negative space: add 1 to the most significant bit\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    // becomes 0x10000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    let negative_domain = token_address + NULLIFIER_DOMAIN_SEPARATOR;\n    pedersen_commitment_token(m, r, negative_domain * mult)\n}\n\npub fn pedersen_commitment_counter(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // negative space: add 1 to the most significant bit\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    // becomes 0x20000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    let counter_domain = token_address + COUNTER_DOMAIN_SEPARATOR;\n    pedersen_commitment_token(m, r, counter_domain)\n}\n\n\npub fn pedersen_commitment_positive(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // positive space: token_address (original)\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    pedersen_commitment_token(m, r, token_address)\n}\n\n// === COMMITMENT VERIFICATION ===\n\npub fn verify_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field) -> bool {\n    let computed_commitment = pedersen_commitment_token(m, r, token_address);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\npub fn verify_negative_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field, mult: Field) -> bool {\n    let computed_commitment = pedersen_commitment_negative(m, r, token_address, mult);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\npub fn verify_positive_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field) -> bool {\n    let computed_commitment = pedersen_commitment_positive(m, r, token_address);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\n// === COMMITMENT ARITHMETIC ===\n\npub fn add_commitments(c1: EmbeddedCurvePoint, c2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    c1 + c2\n}\n\npub fn add_multiple_commitments(commitments: [EmbeddedCurvePoint]) -> EmbeddedCurvePoint {\n    let mut result = EmbeddedCurvePoint::point_at_infinity();\n    \n    for i in 0..commitments.len() {\n        if i == 0 {\n            result = commitments[i];\n        } else {\n            result = result + commitments[i];\n        }\n    }\n    \n    result\n}\n\npub fn subtract_commitments(c1: EmbeddedCurvePoint, c2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // c1 - c2 = c1 + (-c2)\n    let neg_c2 = -c2;\n    c1 + neg_c2\n}\n\n\n// === BALANCE VERIFICATION ===\n// Proves that negative commitments >= positive commitments\n\npub fn verify_balance_proof(\n    negative_commitment: EmbeddedCurvePoint,\n    positive_commitment: EmbeddedCurvePoint,\n    total_commitment: EmbeddedCurvePoint,\n    negative_m: Field,\n    negative_r: Field,\n    positive_m: Field,\n    positive_r: Field,\n    token_address: Field\n) -> bool {\n    // Verify commitment openings\n    let negative_valid = verify_negative_commitment_opening(negative_commitment, negative_m, negative_r, token_address, 1);\n    let positive_valid = verify_positive_commitment_opening(positive_commitment, positive_m, positive_r, token_address);\n    \n    // Verify arithmetic: negative + positive = total\n    let sum_commitment = add_commitments(negative_commitment, positive_commitment);\n    let x_equal = sum_commitment.x == total_commitment.x;\n    let y_equal = sum_commitment.y == total_commitment.y;\n    let arithmetic_valid = x_equal & y_equal;\n    \n    // Verify sufficient balance: negative_m >= positive_m\n    let balance_valid = (negative_m as u128) >= (positive_m as u128);\n    \n    ((negative_valid as u1) & (positive_valid as u1) & (arithmetic_valid as u1) & (balance_valid as u1)) as bool\n}\n\n// === UTILITY FUNCTIONS ===\n\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\nfn from_field(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = compute_decomposition(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/pedersen-commitments/src/pedersen_commitments.nr"},"88":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon/src/poseidon2.nr"},"90":{"source":"use dep::std;\r\nuse dep::poseidon::poseidon2::Poseidon2;\r\n\r\n/// Poseidon CTR Mode Encryption Library\r\n/// \r\n/// This library provides Poseidon-based encryption in CTR mode for field elements.\r\n/// It includes functions for encrypting individual fields and batch encryption.\r\n\r\n/// Generate a keystream using Poseidon with key and nonce\r\npub fn poseidon_keystream(key: Field, nonce: u32) -> Field {\r\n    // === POSEIDON KEYSTREAM GENERATION ===\r\n    // Generate keystream using Poseidon with key and nonce\r\n    \r\n    // Use the public hash function with key and nonce\r\n    Poseidon2::hash([key, nonce as Field], 2)\r\n}\r\n\r\n/// Encrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_encrypt(plaintext: Field, key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE ENCRYPTION ===\r\n    // Use Poseidon to generate keystream for CTR mode encryption\r\n    \r\n    // Generate keystream using Poseidon with key and counter\r\n    let keystream = poseidon_keystream(key, counter);\r\n    \r\n    // Encrypt by adding keystream to plaintext (field arithmetic equivalent of XOR)\r\n    let ciphertext = plaintext + keystream;\r\n    \r\n    ciphertext\r\n}\r\n\r\n/// Decrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_decrypt(ciphertext: Field, key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE DECRYPTION ===\r\n    // Decryption is the same as encryption in CTR mode\r\n    \r\n    // Generate the same keystream\r\n    let keystream = poseidon_keystream(key, counter);\r\n    \r\n    // Decrypt by subtracting keystream from ciphertext\r\n    let plaintext = ciphertext - keystream;\r\n    \r\n    plaintext\r\n}\r\n\r\n/// Encrypt all four fields (amount, token_address, ref, encryption_key) in one function call\r\n/// This provides integrity checking - the ref value can be verified when absorbing the note\r\npub fn poseidon_encrypt_all_fields(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> (Field, Field, Field, Field) {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ===\r\n    // Encrypt all four fields with different counters in one function call\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    let encrypted_key = poseidon_ctr_encrypt(encryption_key, encryption_key, 3);\r\n    \r\n    (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n/// Encrypt all four fields and return as array for cleaner API\r\npub fn poseidon_encrypt_all_fields_array(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> [Field; 3] {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ARRAY ===\r\n    // Encrypt all four fields and return the first 3 as an array\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    \r\n    [encrypted_amount, encrypted_token_address, encrypted_ref]\r\n}\r\n\r\n// ===== BASIC FUNCTIONALITY TESTS =====\r\n\r\n#[test]\r\nfn test_basic_encryption_decryption() {\r\n    // Test basic encryption and decryption round-trip\r\n    let plaintext = 12345 as Field;\r\n    let key = Poseidon2::hash([42 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_zero_plaintext() {\r\n    // Test encryption of zero value\r\n    let plaintext = 0 as Field;\r\n    let key = Poseidon2::hash([123 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_large_plaintext() {\r\n    // Test encryption of large field value (using a large but valid field value)\r\n    let plaintext = 21888242871839275222246405745257275088548364400416034343698204186575808495616 as Field; // p-1\r\n    let key = Poseidon2::hash([456 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n// ===== COUNTER/KEYSTREAM TESTS =====\r\n\r\n#[test]\r\nfn test_different_counters_produce_different_ciphertexts() {\r\n    // Test that different counters produce different ciphertexts\r\n    let plaintext = 1000 as Field;\r\n    let key = Poseidon2::hash([789 as Field], 1);\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, key, 0);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, key, 1);\r\n    let ciphertext3 = poseidon_ctr_encrypt(plaintext, key, 2);\r\n    \r\n    // All ciphertexts should be different\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n    \r\n    // But all should decrypt to the same plaintext\r\n    assert(poseidon_ctr_decrypt(ciphertext1, key, 0) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext2, key, 1) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext3, key, 2) == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_consistency() {\r\n    // Test that same inputs produce same keystream\r\n    let key = Poseidon2::hash([999 as Field], 1);\r\n    let nonce = 5 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(key, nonce);\r\n    let keystream2 = poseidon_keystream(key, nonce);\r\n    \r\n    assert(keystream1 == keystream2);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_nonces() {\r\n    // Test that different nonces produce different keystreams\r\n    let key = Poseidon2::hash([111 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(key, 0);\r\n    let keystream2 = poseidon_keystream(key, 1);\r\n    let keystream3 = poseidon_keystream(key, 2);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_keys() {\r\n    // Test that different keys produce different keystreams\r\n    let nonce = 0 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(Poseidon2::hash([1 as Field], 1), nonce);\r\n    let keystream2 = poseidon_keystream(Poseidon2::hash([2 as Field], 1), nonce);\r\n    let keystream3 = poseidon_keystream(Poseidon2::hash([3 as Field], 1), nonce);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n// ===== BATCH ENCRYPTION TESTS =====\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_basic() {\r\n    // Test batch encryption of all four fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Verify each field can be decrypted individually\r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_zero_values() {\r\n    // Test batch encryption with zero values\r\n    let amount = 0 as Field;\r\n    let token_address = 0 as Field;\r\n    let ref = 0 as Field;\r\n    let encryption_key = Poseidon2::hash([0 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_different_keys() {\r\n    // Test that different encryption keys produce different results\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    \r\n    let key1 = Poseidon2::hash([111 as Field], 1);\r\n    let key2 = Poseidon2::hash([222 as Field], 1);\r\n    \r\n    let (enc1_amount, enc1_token, enc1_ref, enc1_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key1\r\n    );\r\n    \r\n    let (enc2_amount, enc2_token, enc2_ref, enc2_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key2\r\n    );\r\n    \r\n    // Different keys should produce different ciphertexts\r\n    assert(enc1_amount != enc2_amount);\r\n    assert(enc1_token != enc2_token);\r\n    assert(enc1_ref != enc2_ref);\r\n    assert(enc1_key != enc2_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_integrity_check() {\r\n    // Test that the ref and key values provide integrity checking\r\n    let amount = 5000 as Field;\r\n    let token_address = 6000 as Field;\r\n    let ref = 7000 as Field;\r\n    let encryption_key = Poseidon2::hash([777 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Decrypt the ref and key values - they should match the original values\r\n    let decrypted_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n    // This provides integrity: if someone tries to use a different key to decrypt,\r\n    // the values won't match, indicating tampering\r\n    let wrong_key = Poseidon2::hash([888 as Field], 1);\r\n    let wrong_decrypted_ref = poseidon_ctr_decrypt(enc_ref, wrong_key, 2);\r\n    let wrong_decrypted_key = poseidon_ctr_decrypt(enc_key, wrong_key, 3);\r\n    assert(wrong_decrypted_ref != ref);\r\n    assert(wrong_decrypted_key != encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_array() {\r\n    // Test the array version of encrypt all fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let encrypted_array = poseidon_encrypt_all_fields_array(amount, token_address, ref, encryption_key);\r\n    \r\n    // Verify array has 3 elements\r\n    assert(encrypted_array.len() == 3);\r\n    \r\n    // Verify each element can be decrypted\r\n    let dec_amount = poseidon_ctr_decrypt(encrypted_array[0], encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(encrypted_array[1], encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(encrypted_array[2], encryption_key, 2);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n}\r\n\r\n// ===== SECURITY TESTS =====\r\n\r\n#[test]\r\nfn test_wrong_key_fails_decryption() {\r\n    // Test that decryption with wrong key fails\r\n    let plaintext = 5000 as Field;\r\n    let correct_key = Poseidon2::hash([111 as Field], 1);\r\n    let wrong_key = Poseidon2::hash([222 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, correct_key, counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, wrong_key, counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_wrong_counter_fails_decryption() {\r\n    // Test that decryption with wrong counter fails\r\n    let plaintext = 7777 as Field;\r\n    let key = Poseidon2::hash([333 as Field], 1);\r\n    let correct_counter = 2 as u32;\r\n    let wrong_counter = 3 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, correct_counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, key, wrong_counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_deterministic() {\r\n    // Test that same inputs always produce same ciphertext\r\n    let plaintext = 8888 as Field;\r\n    let key = Poseidon2::hash([444 as Field], 1);\r\n    let counter = 1 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    \r\n    // Same inputs should produce same ciphertext\r\n    assert(ciphertext1 == ciphertext2);\r\n}\r\n\r\n#[test]\r\nfn test_different_plaintexts_different_ciphertexts() {\r\n    // Test that different plaintexts produce different ciphertexts\r\n    let key = Poseidon2::hash([555 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(1000 as Field, key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(2000 as Field, key, counter);\r\n    let ciphertext3 = poseidon_ctr_encrypt(3000 as Field, key, counter);\r\n    \r\n    // Different plaintexts should produce different ciphertexts\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n}\r\n\r\n// ===== EDGE CASE TESTS =====\r\n\r\n#[test]\r\nfn test_max_counter_value() {\r\n    // Test with maximum counter value\r\n    let plaintext = 1234 as Field;\r\n    let key = Poseidon2::hash([666 as Field], 1);\r\n    let max_counter = 4294967295 as u32; // u32::MAX\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, max_counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, max_counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_preserves_field_arithmetic() {\r\n    // Test that encryption preserves field arithmetic properties\r\n    let a = 1000 as Field;\r\n    let b = 2000 as Field;\r\n    let key = Poseidon2::hash([777 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    // Encrypt individual values\r\n    let enc_a = poseidon_ctr_encrypt(a, key, counter);\r\n    let enc_b = poseidon_ctr_encrypt(b, key, counter);\r\n    \r\n    // Decrypt and verify\r\n    let dec_a = poseidon_ctr_decrypt(enc_a, key, counter);\r\n    let dec_b = poseidon_ctr_decrypt(enc_b, key, counter);\r\n    \r\n    assert(dec_a == a);\r\n    assert(dec_b == b);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_uniformity() {\r\n    // Test that keystreams appear uniformly distributed\r\n    let key = Poseidon2::hash([888 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(key, 0);\r\n    let keystream2 = poseidon_keystream(key, 1);\r\n    let keystream3 = poseidon_keystream(key, 2);\r\n    let keystream4 = poseidon_keystream(key, 3);\r\n    let keystream5 = poseidon_keystream(key, 4);\r\n    \r\n    // All keystreams should be different (very high probability)\r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream3 != keystream4);\r\n    assert(keystream4 != keystream5);\r\n    assert(keystream1 != keystream3);\r\n    assert(keystream1 != keystream4);\r\n    assert(keystream1 != keystream5);\r\n    assert(keystream2 != keystream4);\r\n    assert(keystream2 != keystream5);\r\n    assert(keystream3 != keystream5);\r\n}\r\n\r\n// ===== TEST FOR TYPESCRIPT COMPARISON =====\r\n\r\n/// Get test values for TypeScript comparison\r\npub fn get_poseidon_ctr_test_values() -> (Field, Field, Field, Field, Field, Field, Field, Field) {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Return all values for external testing\r\n    (amount, token_address, ref, encryption_key, encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n#[test]\r\nfn test_poseidon_ctr_encryption_values() {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Decrypt all fields\r\n    let decrypted_amount = poseidon_ctr_decrypt(encrypted_amount, encryption_key, 0);\r\n    let decrypted_token_address = poseidon_ctr_decrypt(encrypted_token_address, encryption_key, 1);\r\n    let decrypted_ref = poseidon_ctr_decrypt(encrypted_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(encrypted_key, encryption_key, 3);\r\n    \r\n    // Verify round-trip encryption/decryption\r\n    assert(decrypted_amount == amount);\r\n    assert(decrypted_token_address == token_address);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n \r\n    println(\"Encrypted amount: 0x{:x}\");\r\n    println(encrypted_amount);\r\n    println(\"Encrypted token address: 0x{:x}\");\r\n    println(encrypted_token_address);\r\n    println(\"Encrypted ref: 0x{:x}\");\r\n    println(encrypted_ref);\r\n    println(\"Encrypted key: 0x{:x}\");\r\n    println(encrypted_key);\r\n    println(\"Decrypted amount: 0x{:x}\");\r\n    println(decrypted_amount);\r\n    println(\"Decrypted token address: 0x{:x}\");\r\n    println(decrypted_token_address);\r\n    println(\"Decrypted ref: 0x{:x}\");\r\n    println(decrypted_ref);\r\n    println(\"Decrypted key: 0x{:x}\");\r\n    println(decrypted_key);\r\n}\r\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon-ctr-encryption/src/lib.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}