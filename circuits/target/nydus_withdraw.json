{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":16680516655751925008,"abi":{"parameters":[{"name":"user_key","type":{"kind":"field"},"visibility":"private"},{"name":"token_address","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"previous_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"main_c_tot","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"main_c_inner","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"main_c_outer","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"main_c_inner_point","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"main_c_outer_point","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_tot","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_inner","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_outer","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"personal_c_inner_m","type":{"kind":"field"},"visibility":"private"},{"name":"personal_c_outer_m","type":{"kind":"field"},"visibility":"private"},{"name":"personal_c_outer_r","type":{"kind":"field"},"visibility":"private"},{"name":"arbitrary_calldata_hash","type":{"kind":"field"},"visibility":"public"},{"name":"receiver_address","type":{"kind":"field"},"visibility":"public"},{"name":"relay_fee_token_address","type":{"kind":"field"},"visibility":"public"},{"name":"receiver_fee_amount","type":{"kind":"field"},"visibility":"public"},{"name":"fee_token_personal_c_inner","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"fee_token_personal_c_outer","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"fee_token_personal_c_inner_m","type":{"kind":"field"},"visibility":"private"},{"name":"fee_token_personal_c_outer_m","type":{"kind":"field"},"visibility":"private"},{"name":"fee_token_personal_c_outer_r","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"array","length":2,"type":{"kind":"field"}},{"kind":"array","length":5,"type":{"kind":"field"}},{"kind":"array","length":2,"type":{"kind":"field"}},{"kind":"array","length":2,"type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"1612527314196857042":{"error_kind":"string","string":"Main total commitment y verification failed"},"1773109170529334064":{"error_kind":"string","string":"Fee amount exceeds available fee token balance"},"1829188810346778472":{"error_kind":"string","string":"Main total commitment x verification failed"},"3148389928304926912":{"error_kind":"string","string":"Withdrawal amount exceeds available balance"},"4595064417801177898":{"error_kind":"string","string":"Main outer commitment x verification failed"},"4870430370618040774":{"error_kind":"string","string":"Decrypted y coordinate doesn't match personal_c_tot"},"5016858004930596942":{"error_kind":"string","string":"Total commitment verification failed"},"5953736523571907205":{"error_kind":"string","string":"Main outer commitment y verification failed"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6662057465190892192":{"error_kind":"string","string":"Main inner commitment y verification failed"},"10325993214499467633":{"error_kind":"string","string":"Insufficient balance for withdrawal and fee"},"10612215498520620440":{"error_kind":"string","string":"Decrypted x coordinate doesn't match personal_c_tot"},"11045699237078081382":{"error_kind":"string","string":"Main inner commitment x verification failed"},"11111546544413083335":{"error_kind":"string","string":"Fee token inner commitment y verification failed"},"11740974266937565723":{"error_kind":"string","string":"Outer commitment verification failed"},"14721261026514454637":{"error_kind":"string","string":"Fee token outer commitment verification failed"},"14919676320828105352":{"error_kind":"string","string":"Fee token inner commitment x verification failed"},"15653880448467002131":{"error_kind":"string","string":"Inner commitment y verification failed"},"17493575164725668030":{"error_kind":"string","string":"Inner commitment x verification failed"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"use dep::std;\nuse dep::std::field::bn254::{assert_gt, gt};\nuse dep::poseidon::poseidon2::Poseidon2;\nuse dep::poseidon_ctr_encryption::{poseidon_ctr_encrypt, poseidon_ctr_decrypt};\nuse dep::pedersen_commitments::pedersen_commitments::{\n    pedersen_commitment_positive,\n    pedersen_commitment_negative,\n    add_commitments,\n    add_multiple_commitments,\n    subtract_commitments,\n    pedersen_commitment_non_hiding\n};\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint;\nmod test;\n\nglobal VIEW_STRING: Field = 0x76696577696e675f6b6579 as Field;\n\n\n\n\nfn main(\n    user_key: Field,\n    token_address: pub Field,\n    amount: pub Field,\n    previous_nonce: Field,\n    main_c_tot: pub [Field; 2],\n    main_c_inner: [Field; 2],\n    main_c_outer: [Field; 2],\n    main_c_inner_point: [Field; 2],\n    main_c_outer_point: [Field; 3],\n    personal_c_tot: [Field; 2],\n    personal_c_inner: [Field; 2],\n    personal_c_outer: [Field; 2],\n    personal_c_inner_m: Field,\n    personal_c_outer_m: Field,\n    personal_c_outer_r: Field,\n    arbitrary_calldata_hash: pub Field,\n    receiver_address: pub Field,\n    relay_fee_token_address: pub Field,\n    receiver_fee_amount: pub Field,\n    fee_token_personal_c_inner: [Field; 2],\n    fee_token_personal_c_outer: [Field; 2],\n    fee_token_personal_c_inner_m: Field,\n    fee_token_personal_c_outer_m: Field,\n    fee_token_personal_c_outer_r: Field\n) -> pub (Field, [Field; 2], [Field; 5], [Field; 2], [Field; 2]) {\n    let user_key_hash = Poseidon2::hash([user_key], 1);\n    let view_key = Poseidon2::hash([VIEW_STRING, user_key_hash], 2);\n    let previous_nonce_commitment = Poseidon2::hash([user_key_hash, previous_nonce as Field], 2);\n    let current_balance = personal_c_inner_m;\n    let fee_token_current_balance = fee_token_personal_c_inner_m;\n    let tokens_same = token_address == relay_fee_token_address;\n    \n    verify_main_commitments(\n        main_c_tot,\n        main_c_inner,\n        main_c_outer,\n        main_c_inner_point,\n        main_c_outer_point,\n        previous_nonce_commitment,\n        view_key,\n        previous_nonce\n    );\n    \n    verify_personal_commitments(\n        personal_c_tot,\n        personal_c_inner,\n        personal_c_outer,\n        personal_c_inner_m,\n        personal_c_outer_m,\n        personal_c_outer_r,\n        token_address,\n        user_key_hash,\n        main_c_inner_point,\n        view_key,\n        previous_nonce,\n        tokens_same,\n        fee_token_personal_c_inner\n    );\n    \n    if !tokens_same {\n        verify_fee_token_personal_commitments(\n            fee_token_personal_c_inner,\n            fee_token_personal_c_outer,\n            fee_token_personal_c_inner_m,\n            fee_token_personal_c_outer_m,\n            fee_token_personal_c_outer_r,\n            relay_fee_token_address,\n            user_key_hash\n        );\n    }\n    \n    let nonce = previous_nonce + 1 as Field;\n    let new_nonce_commitment = Poseidon2::hash([user_key_hash, nonce as Field], 2);\n    \n    if tokens_same {\n        assert(gt(current_balance, amount + receiver_fee_amount - 1), \"Insufficient balance for withdrawal and fee\");\n    } else {\n        assert(gt(current_balance, amount - 1), \"Withdrawal amount exceeds available balance\");\n        assert(gt(fee_token_current_balance, receiver_fee_amount - 1), \"Fee amount exceeds available fee token balance\");\n    }\n    \n    let (new_main_commitment, enc_x, enc_y) = create_new_commitments(\n        current_balance,\n        amount,\n        personal_c_tot,\n        personal_c_inner,\n        fee_token_personal_c_inner,\n        fee_token_current_balance,\n        receiver_fee_amount,\n        token_address,\n        relay_fee_token_address,\n        user_key_hash,\n        new_nonce_commitment,\n        view_key,\n        nonce,\n        tokens_same\n    );\n    \n    let encrypted_note = encrypt_operation_details(\n        current_balance,\n        token_address,\n        nonce,\n        view_key,\n        personal_c_tot,\n        personal_c_inner,\n        personal_c_inner_m,\n        fee_token_personal_c_inner,\n        fee_token_personal_c_inner_m,\n        fee_token_current_balance,\n        receiver_fee_amount,\n        amount,\n        user_key_hash,\n        relay_fee_token_address,\n        tokens_same\n    );\n    \n    let nonce_discovery_entry = pedersen_commitment_non_hiding(1, new_nonce_commitment);\n    \n    (   \n        new_nonce_commitment,\n        [new_main_commitment.x, new_main_commitment.y],\n        encrypted_note,\n        [nonce_discovery_entry.x, nonce_discovery_entry.y],\n        [enc_x, enc_y]\n    )\n}\n\n\n\nfn verify_main_commitments(\n    main_c_tot: [Field; 2],\n    main_c_inner: [Field; 2], \n    main_c_outer: [Field; 2],\n    main_c_inner_point: [Field; 2],\n    main_c_outer_point: [Field; 3],\n    previous_nonce_commitment: Field,\n    view_key: Field,\n    previous_nonce: Field\n) {\n    let reconstructed_main_c_inner = pedersen_commitment_positive(main_c_inner_point[0], main_c_inner_point[1], previous_nonce_commitment);\n    assert(reconstructed_main_c_inner.x == main_c_inner[0], \"Main inner commitment x verification failed\");\n    assert(reconstructed_main_c_inner.y == main_c_inner[1], \"Main inner commitment y verification failed\");\n\n    let reconstructed_main_c_outer = pedersen_commitment_positive(main_c_outer_point[0], main_c_outer_point[1], main_c_outer_point[2]);\n    assert(reconstructed_main_c_outer.x == main_c_outer[0], \"Main outer commitment x verification failed\");\n    assert(reconstructed_main_c_outer.y == main_c_outer[1], \"Main outer commitment y verification failed\");\n\n    let main_c_tot_commitment = add_commitments(reconstructed_main_c_inner, reconstructed_main_c_outer);\n    assert(main_c_tot_commitment.x == main_c_tot[0], \"Main total commitment x verification failed\");\n    assert(main_c_tot_commitment.y == main_c_tot[1], \"Main total commitment y verification failed\");\n}\n\nfn verify_personal_commitments(\n    personal_c_tot: [Field; 2],\n    personal_c_inner: [Field; 2],\n    personal_c_outer: [Field; 2],\n    personal_c_inner_m: Field,\n    personal_c_outer_m: Field,\n    personal_c_outer_r: Field,\n    token_address: Field,\n    user_key_hash: Field,\n    main_c_inner_point: [Field; 2],\n    view_key: Field,\n    previous_nonce: Field,\n    tokens_same: bool,\n    fee_token_personal_c_inner: [Field; 2]\n) {\n    let personal_c_inner_m_hash = Poseidon2::hash([personal_c_inner_m, user_key_hash], 2);\n    let personal_c_inner_token_address_hash = Poseidon2::hash([token_address, user_key_hash], 2);\n    \n    let inner_commitment = pedersen_commitment_non_hiding(personal_c_inner_m_hash, personal_c_inner_token_address_hash);\n    assert(inner_commitment.x == personal_c_inner[0], \"Inner commitment x verification failed\");\n    assert(inner_commitment.y == personal_c_inner[1], \"Inner commitment y verification failed\");\n\n    let outer_commitment = pedersen_commitment_non_hiding(personal_c_outer_m, personal_c_outer_r);\n    assert(outer_commitment.x == personal_c_outer[0], \"Outer commitment verification failed\");\n    assert(outer_commitment.y == personal_c_outer[1], \"Outer commitment verification failed\");\n    \n    let initializer = pedersen_commitment_non_hiding(token_address, user_key_hash);\n    \n    if tokens_same {\n        let sum_with_initializer = add_multiple_commitments([\n            inner_commitment,\n            outer_commitment,\n            initializer\n        ]);\n        \n        let sum_without_initializer = add_multiple_commitments([\n            inner_commitment,\n            outer_commitment\n        ]);\n        \n        let with_initializer_matches = (sum_with_initializer.x == personal_c_tot[0]) & (sum_with_initializer.y == personal_c_tot[1]);\n        let without_initializer_matches = (sum_without_initializer.x == personal_c_tot[0]) & (sum_without_initializer.y == personal_c_tot[1]);\n        \n        assert(with_initializer_matches | without_initializer_matches, \"Total commitment verification failed\");\n    } else {\n        let fee_token_personal_c_inner_commitment = EmbeddedCurvePoint { x: fee_token_personal_c_inner[0], y: fee_token_personal_c_inner[1], is_infinite: false };\n        let personal_c_tot_commitment = EmbeddedCurvePoint { x: personal_c_tot[0], y: personal_c_tot[1], is_infinite: false };\n        \n        let computed_outer = subtract_commitments(\n            subtract_commitments(personal_c_tot_commitment, inner_commitment),\n            fee_token_personal_c_inner_commitment\n        );\n        \n        let sum = add_multiple_commitments([\n            inner_commitment,\n            fee_token_personal_c_inner_commitment,\n            computed_outer\n        ]);\n        \n        let sum_matches = (sum.x == personal_c_tot[0]) & (sum.y == personal_c_tot[1]);\n        \n        assert(sum_matches, \"Total commitment verification failed\");\n    }\n    \n    let previous_encryption_key = Poseidon2::hash([view_key, previous_nonce], 2);\n    let decrypted_x = poseidon_ctr_decrypt(main_c_inner_point[0], previous_encryption_key, 3);\n    let decrypted_y = poseidon_ctr_decrypt(main_c_inner_point[1], previous_encryption_key, 4);\n    \n    assert(decrypted_x == personal_c_tot[0], \"Decrypted x coordinate doesn't match personal_c_tot\");\n    assert(decrypted_y == personal_c_tot[1], \"Decrypted y coordinate doesn't match personal_c_tot\");\n}\n\nfn create_new_commitments(\n    current_balance: Field,\n    amount: Field,\n    personal_c_tot: [Field; 2],\n    personal_c_inner: [Field; 2],\n    fee_token_personal_c_inner: [Field; 2],\n    fee_token_current_balance: Field,\n    receiver_fee_amount: Field,\n    token_address: Field,\n    relay_fee_token_address: Field,\n    user_key_hash: Field,\n    new_nonce_commitment: Field,\n    view_key: Field,\n    nonce: Field,\n    tokens_same: bool\n) -> (EmbeddedCurvePoint, Field, Field) {\n    let personal_c_tot_commitment = EmbeddedCurvePoint { x: personal_c_tot[0], y: personal_c_tot[1], is_infinite: false };\n    let personal_c_inner_commitment = EmbeddedCurvePoint { x: personal_c_inner[0], y: personal_c_inner[1], is_infinite: false };\n    \n    let outer_commitment = if tokens_same {\n        subtract_commitments(personal_c_tot_commitment, personal_c_inner_commitment)\n    } else {\n        let fee_token_personal_c_inner_commitment = EmbeddedCurvePoint { x: fee_token_personal_c_inner[0], y: fee_token_personal_c_inner[1], is_infinite: false };\n        subtract_commitments(\n            subtract_commitments(personal_c_tot_commitment, personal_c_inner_commitment),\n            fee_token_personal_c_inner_commitment\n        )\n    };\n    \n    let new_balance = if tokens_same {\n        current_balance - amount - receiver_fee_amount\n    } else {\n        current_balance - amount\n    };\n    \n    let new_balance_commitment = pedersen_commitment_non_hiding(new_balance, token_address);\n    \n    let new_personal_c_tot_commitment = if tokens_same {\n        add_commitments(outer_commitment, new_balance_commitment)\n    } else {\n        let fee_token_new_balance = fee_token_current_balance - receiver_fee_amount;\n        let fee_token_new_balance_hash = Poseidon2::hash([fee_token_new_balance, user_key_hash], 2);\n        let fee_token_token_address_hash = Poseidon2::hash([relay_fee_token_address, user_key_hash], 2);\n        let new_fee_balance_commitment = pedersen_commitment_non_hiding(fee_token_new_balance_hash, fee_token_token_address_hash);\n        add_multiple_commitments([\n            outer_commitment,\n            new_balance_commitment,\n            new_fee_balance_commitment\n        ])\n    };\n    \n    let encryption_key = Poseidon2::hash([view_key, nonce], 2);\n    let enc_x = poseidon_ctr_encrypt(new_personal_c_tot_commitment.x, encryption_key, 3);\n    let enc_y = poseidon_ctr_encrypt(new_personal_c_tot_commitment.y, encryption_key, 4);\n    \n    let new_main_commitment = pedersen_commitment_positive(\n        enc_x,\n        enc_y,\n        new_nonce_commitment\n    );\n    \n    // Return the new main commitment and encrypted coordinates\n    (new_main_commitment, enc_x, enc_y)\n}\n\nfn verify_fee_token_personal_commitments(\n    fee_token_personal_c_inner: [Field; 2],\n    fee_token_personal_c_outer: [Field; 2],\n    fee_token_personal_c_inner_m: Field,\n    fee_token_personal_c_outer_m: Field,\n    fee_token_personal_c_outer_r: Field,\n    relay_fee_token_address: Field,\n    user_key_hash: Field\n) {\n    let fee_token_personal_c_inner_m_hash = Poseidon2::hash([fee_token_personal_c_inner_m, user_key_hash], 2);\n    let fee_token_personal_c_inner_token_address_hash = Poseidon2::hash([relay_fee_token_address, user_key_hash], 2);\n    \n    let fee_token_inner_commitment = pedersen_commitment_non_hiding(fee_token_personal_c_inner_m_hash, fee_token_personal_c_inner_token_address_hash);\n    assert(fee_token_inner_commitment.x == fee_token_personal_c_inner[0], \"Fee token inner commitment x verification failed\");\n    assert(fee_token_inner_commitment.y == fee_token_personal_c_inner[1], \"Fee token inner commitment y verification failed\");\n\n    let fee_token_outer_commitment = pedersen_commitment_non_hiding(fee_token_personal_c_outer_m, fee_token_personal_c_outer_r);\n    assert(fee_token_outer_commitment.x == fee_token_personal_c_outer[0], \"Fee token outer commitment verification failed\");\n    assert(fee_token_outer_commitment.y == fee_token_personal_c_outer[1], \"Fee token outer commitment verification failed\");\n    \n    let fee_token_sum_commitment = add_commitments(fee_token_inner_commitment, fee_token_outer_commitment);\n    assert(fee_token_sum_commitment.x == fee_token_sum_commitment.x, \"Fee token total commitment verification\");\n    assert(fee_token_sum_commitment.y == fee_token_sum_commitment.y, \"Fee token total commitment verification\");\n}\n\nfn encrypt_operation_details(\n    current_balance: Field,\n    token_address: Field,\n    nonce: Field,\n    view_key: Field,\n    personal_c_tot: [Field; 2],\n    personal_c_inner: [Field; 2],\n    personal_c_inner_m: Field,\n    fee_token_personal_c_inner: [Field; 2],\n    fee_token_personal_c_inner_m: Field,\n    fee_token_current_balance: Field,\n    receiver_fee_amount: Field,\n    amount: Field,\n    user_key_hash: Field,\n    relay_fee_token_address: Field,\n    tokens_same: bool\n) -> [Field; 5] {\n    let encryption_key = Poseidon2::hash([view_key, nonce], 2);\n\n    let new_balance = if tokens_same {\n        current_balance - amount - receiver_fee_amount\n    } else {\n        current_balance - amount\n    };\n    \n    let (new_personal_c_tot_m, new_personal_c_tot_r) = if tokens_same {\n        (new_balance, token_address)\n    } else {\n        let fee_token_new_balance = fee_token_current_balance - receiver_fee_amount;\n        let fee_token_new_balance_hash = Poseidon2::hash([fee_token_new_balance, user_key_hash], 2);\n        let fee_token_token_address_hash = Poseidon2::hash([relay_fee_token_address, user_key_hash], 2);\n        (new_balance + fee_token_new_balance_hash, token_address + fee_token_token_address_hash)\n    };\n\n    let encrypted_amount = poseidon_ctr_encrypt(new_balance, encryption_key, 0);\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\n    \n    let view_key_hash = Poseidon2::hash([encryption_key], 1);\n    let encrypted_reference = poseidon_ctr_encrypt(view_key_hash, encryption_key, 2);\n    \n    let encrypted_personal_c_tot_m = poseidon_ctr_encrypt(new_personal_c_tot_m, encryption_key, 3);\n    let encrypted_personal_c_tot_r = poseidon_ctr_encrypt(new_personal_c_tot_r, encryption_key, 4);\n    \n    [encrypted_amount, encrypted_token_address, encrypted_reference, encrypted_personal_c_tot_m, encrypted_personal_c_tot_r]\n}\n","path":"/home/drone/projects/ethrome25/circuits/main/nydus-withdraw/src/main.nr"},"71":{"source":"use dep::std;\nuse dep::std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\nglobal NULLIFIER_DOMAIN_SEPARATOR: Field \n    = 0x100000000000000000000000000000000000000000000000000000000000000;\n\nglobal COUNTER_DOMAIN_SEPARATOR: Field \n    = 0x200000000000000000000000000000000000000000000000000000000000000;\n\n\npub fn pedersen_commitment_token(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // Use derive_generators to get different generators for G and H\n    let generators: [EmbeddedCurvePoint; 3] =\n        std::hash::derive_generators(\"PEDERSEN_COMMITMENT\".as_bytes(), 0);\n    \n    let G = generators[0];  // First generator for amount\n    let H = generators[1];  // Second generator for blinding factor\n    let D = generators[2];  // Third generator for domain separation\n     // Create scalars for multi_scalar_mul\n    let mut scalars = [EmbeddedCurveScalar { lo: 0, hi: 0 }; 3];\n    scalars[0] = from_field(m);\n    scalars[1] = from_field(r);\n    scalars[2] = from_field(token_address);\n    \n    // Create points for multi_scalar_mul: [G, H, D]\n    let mut points = [EmbeddedCurvePoint::point_at_infinity(); 3];\n    points[0] = G;\n    points[1] = H;\n    points[2] = D;  \n    \n    // Compute commitment: m*G + r*H + token_address*D\n    multi_scalar_mul(points, scalars)\n}\n\npub fn pedersen_commitment_non_hiding(m: Field, token_address: Field) -> EmbeddedCurvePoint {\n    let generators: [EmbeddedCurvePoint; 3] =\n        std::hash::derive_generators(\"PEDERSEN_COMMITMENT_PERSONAL\".as_bytes(), 0);\n    \n    let G = generators[0];  // \n    let D = generators[1];  // \n     // Create scalars for multi_scalar_mul\n    let mut scalars = [EmbeddedCurveScalar { lo: 0, hi: 0 }; 2];\n    scalars[0] = from_field(m);\n    scalars[1] = from_field(token_address);\n    \n    // Create points for multi_scalar_mul: [G, H, D]\n    let mut points = [EmbeddedCurvePoint::point_at_infinity(); 2];\n    points[0] = G;\n    points[1] = D;\n    \n    // Compute commitment: m*G + r*H + token_address*D\n    multi_scalar_mul(points, scalars)\n}\n\n\n\npub fn to_negative_domain(token_address: Field) -> Field {\n    token_address + NULLIFIER_DOMAIN_SEPARATOR\n}\n\npub fn to_nullifier_domain(token_address: Field) -> Field {\n    token_address + NULLIFIER_DOMAIN_SEPARATOR\n}\n\n\n\n// === DOMAIN SEPARATION FOR negative/positive ===\n// Creates distinct commitment spaces for the same token\n\npub fn pedersen_commitment_negative(m: Field, r: Field, token_address: Field, mult: Field) -> EmbeddedCurvePoint {\n    // negative space: add 1 to the most significant bit\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    // becomes 0x10000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    let negative_domain = token_address + NULLIFIER_DOMAIN_SEPARATOR;\n    pedersen_commitment_token(m, r, negative_domain * mult)\n}\n\npub fn pedersen_commitment_counter(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // negative space: add 1 to the most significant bit\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    // becomes 0x20000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    let counter_domain = token_address + COUNTER_DOMAIN_SEPARATOR;\n    pedersen_commitment_token(m, r, counter_domain)\n}\n\n\npub fn pedersen_commitment_positive(m: Field, r: Field, token_address: Field) -> EmbeddedCurvePoint {\n    // positive space: token_address (original)\n    // 0x00000000000000000000000058002bee8f43bf203964d38c54fa03e62d615959fa\n    pedersen_commitment_token(m, r, token_address)\n}\n\n// === COMMITMENT VERIFICATION ===\n\npub fn verify_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field) -> bool {\n    let computed_commitment = pedersen_commitment_token(m, r, token_address);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\npub fn verify_negative_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field, mult: Field) -> bool {\n    let computed_commitment = pedersen_commitment_negative(m, r, token_address, mult);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\npub fn verify_positive_commitment_opening(commitment: EmbeddedCurvePoint, m: Field, r: Field, token_address: Field) -> bool {\n    let computed_commitment = pedersen_commitment_positive(m, r, token_address);\n    let x_equal = computed_commitment.x == commitment.x;\n    let y_equal = computed_commitment.y == commitment.y;\n    x_equal & y_equal\n}\n\n// === COMMITMENT ARITHMETIC ===\n\npub fn add_commitments(c1: EmbeddedCurvePoint, c2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    c1 + c2\n}\n\npub fn add_multiple_commitments(commitments: [EmbeddedCurvePoint]) -> EmbeddedCurvePoint {\n    let mut result = EmbeddedCurvePoint::point_at_infinity();\n    \n    for i in 0..commitments.len() {\n        if i == 0 {\n            result = commitments[i];\n        } else {\n            result = result + commitments[i];\n        }\n    }\n    \n    result\n}\n\npub fn subtract_commitments(c1: EmbeddedCurvePoint, c2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // c1 - c2 = c1 + (-c2)\n    let neg_c2 = -c2;\n    c1 + neg_c2\n}\n\n\n// === BALANCE VERIFICATION ===\n// Proves that negative commitments >= positive commitments\n\npub fn verify_balance_proof(\n    negative_commitment: EmbeddedCurvePoint,\n    positive_commitment: EmbeddedCurvePoint,\n    total_commitment: EmbeddedCurvePoint,\n    negative_m: Field,\n    negative_r: Field,\n    positive_m: Field,\n    positive_r: Field,\n    token_address: Field\n) -> bool {\n    // Verify commitment openings\n    let negative_valid = verify_negative_commitment_opening(negative_commitment, negative_m, negative_r, token_address, 1);\n    let positive_valid = verify_positive_commitment_opening(positive_commitment, positive_m, positive_r, token_address);\n    \n    // Verify arithmetic: negative + positive = total\n    let sum_commitment = add_commitments(negative_commitment, positive_commitment);\n    let x_equal = sum_commitment.x == total_commitment.x;\n    let y_equal = sum_commitment.y == total_commitment.y;\n    let arithmetic_valid = x_equal & y_equal;\n    \n    // Verify sufficient balance: negative_m >= positive_m\n    let balance_valid = (negative_m as u128) >= (positive_m as u128);\n    \n    ((negative_valid as u1) & (positive_valid as u1) & (arithmetic_valid as u1) & (balance_valid as u1)) as bool\n}\n\n// === UTILITY FUNCTIONS ===\n\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\nfn from_field(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = compute_decomposition(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/pedersen-commitments/src/pedersen_commitments.nr"},"79":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon/src/poseidon2.nr"},"81":{"source":"use dep::std;\r\nuse dep::poseidon::poseidon2::Poseidon2;\r\n\r\n/// Poseidon CTR Mode Encryption Library\r\n/// \r\n/// This library provides Poseidon-based encryption in CTR mode for field elements.\r\n/// It includes functions for encrypting individual fields and batch encryption.\r\n\r\n/// Generate a keystream using Poseidon with key and nonce\r\npub fn poseidon_keystream(key: Field, nonce: u32) -> Field {\r\n    // === POSEIDON KEYSTREAM GENERATION ===\r\n    // Generate keystream using Poseidon with key and nonce\r\n    \r\n    // Use the public hash function with key and nonce\r\n    Poseidon2::hash([key, nonce as Field], 2)\r\n}\r\n\r\n/// Encrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_encrypt(plaintext: Field, key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE ENCRYPTION ===\r\n    // Use Poseidon to generate keystream for CTR mode encryption\r\n    \r\n    // Generate keystream using Poseidon with key and counter\r\n    let keystream = poseidon_keystream(key, counter);\r\n    \r\n    // Encrypt by adding keystream to plaintext (field arithmetic equivalent of XOR)\r\n    let ciphertext = plaintext + keystream;\r\n    \r\n    ciphertext\r\n}\r\n\r\n/// Decrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_decrypt(ciphertext: Field, key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE DECRYPTION ===\r\n    // Decryption is the same as encryption in CTR mode\r\n    \r\n    // Generate the same keystream\r\n    let keystream = poseidon_keystream(key, counter);\r\n    \r\n    // Decrypt by subtracting keystream from ciphertext\r\n    let plaintext = ciphertext - keystream;\r\n    \r\n    plaintext\r\n}\r\n\r\n/// Encrypt all four fields (amount, token_address, ref, encryption_key) in one function call\r\n/// This provides integrity checking - the ref value can be verified when absorbing the note\r\npub fn poseidon_encrypt_all_fields(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> (Field, Field, Field, Field) {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ===\r\n    // Encrypt all four fields with different counters in one function call\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    let encrypted_key = poseidon_ctr_encrypt(encryption_key, encryption_key, 3);\r\n    \r\n    (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n/// Encrypt all four fields and return as array for cleaner API\r\npub fn poseidon_encrypt_all_fields_array(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> [Field; 3] {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ARRAY ===\r\n    // Encrypt all four fields and return the first 3 as an array\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    \r\n    [encrypted_amount, encrypted_token_address, encrypted_ref]\r\n}\r\n\r\n// ===== BASIC FUNCTIONALITY TESTS =====\r\n\r\n#[test]\r\nfn test_basic_encryption_decryption() {\r\n    // Test basic encryption and decryption round-trip\r\n    let plaintext = 12345 as Field;\r\n    let key = Poseidon2::hash([42 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_zero_plaintext() {\r\n    // Test encryption of zero value\r\n    let plaintext = 0 as Field;\r\n    let key = Poseidon2::hash([123 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_large_plaintext() {\r\n    // Test encryption of large field value (using a large but valid field value)\r\n    let plaintext = 21888242871839275222246405745257275088548364400416034343698204186575808495616 as Field; // p-1\r\n    let key = Poseidon2::hash([456 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n// ===== COUNTER/KEYSTREAM TESTS =====\r\n\r\n#[test]\r\nfn test_different_counters_produce_different_ciphertexts() {\r\n    // Test that different counters produce different ciphertexts\r\n    let plaintext = 1000 as Field;\r\n    let key = Poseidon2::hash([789 as Field], 1);\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, key, 0);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, key, 1);\r\n    let ciphertext3 = poseidon_ctr_encrypt(plaintext, key, 2);\r\n    \r\n    // All ciphertexts should be different\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n    \r\n    // But all should decrypt to the same plaintext\r\n    assert(poseidon_ctr_decrypt(ciphertext1, key, 0) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext2, key, 1) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext3, key, 2) == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_consistency() {\r\n    // Test that same inputs produce same keystream\r\n    let key = Poseidon2::hash([999 as Field], 1);\r\n    let nonce = 5 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(key, nonce);\r\n    let keystream2 = poseidon_keystream(key, nonce);\r\n    \r\n    assert(keystream1 == keystream2);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_nonces() {\r\n    // Test that different nonces produce different keystreams\r\n    let key = Poseidon2::hash([111 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(key, 0);\r\n    let keystream2 = poseidon_keystream(key, 1);\r\n    let keystream3 = poseidon_keystream(key, 2);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_keys() {\r\n    // Test that different keys produce different keystreams\r\n    let nonce = 0 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(Poseidon2::hash([1 as Field], 1), nonce);\r\n    let keystream2 = poseidon_keystream(Poseidon2::hash([2 as Field], 1), nonce);\r\n    let keystream3 = poseidon_keystream(Poseidon2::hash([3 as Field], 1), nonce);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n// ===== BATCH ENCRYPTION TESTS =====\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_basic() {\r\n    // Test batch encryption of all four fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Verify each field can be decrypted individually\r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_zero_values() {\r\n    // Test batch encryption with zero values\r\n    let amount = 0 as Field;\r\n    let token_address = 0 as Field;\r\n    let ref = 0 as Field;\r\n    let encryption_key = Poseidon2::hash([0 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_different_keys() {\r\n    // Test that different encryption keys produce different results\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    \r\n    let key1 = Poseidon2::hash([111 as Field], 1);\r\n    let key2 = Poseidon2::hash([222 as Field], 1);\r\n    \r\n    let (enc1_amount, enc1_token, enc1_ref, enc1_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key1\r\n    );\r\n    \r\n    let (enc2_amount, enc2_token, enc2_ref, enc2_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key2\r\n    );\r\n    \r\n    // Different keys should produce different ciphertexts\r\n    assert(enc1_amount != enc2_amount);\r\n    assert(enc1_token != enc2_token);\r\n    assert(enc1_ref != enc2_ref);\r\n    assert(enc1_key != enc2_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_integrity_check() {\r\n    // Test that the ref and key values provide integrity checking\r\n    let amount = 5000 as Field;\r\n    let token_address = 6000 as Field;\r\n    let ref = 7000 as Field;\r\n    let encryption_key = Poseidon2::hash([777 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Decrypt the ref and key values - they should match the original values\r\n    let decrypted_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n    // This provides integrity: if someone tries to use a different key to decrypt,\r\n    // the values won't match, indicating tampering\r\n    let wrong_key = Poseidon2::hash([888 as Field], 1);\r\n    let wrong_decrypted_ref = poseidon_ctr_decrypt(enc_ref, wrong_key, 2);\r\n    let wrong_decrypted_key = poseidon_ctr_decrypt(enc_key, wrong_key, 3);\r\n    assert(wrong_decrypted_ref != ref);\r\n    assert(wrong_decrypted_key != encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_array() {\r\n    // Test the array version of encrypt all fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let encrypted_array = poseidon_encrypt_all_fields_array(amount, token_address, ref, encryption_key);\r\n    \r\n    // Verify array has 3 elements\r\n    assert(encrypted_array.len() == 3);\r\n    \r\n    // Verify each element can be decrypted\r\n    let dec_amount = poseidon_ctr_decrypt(encrypted_array[0], encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(encrypted_array[1], encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(encrypted_array[2], encryption_key, 2);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n}\r\n\r\n// ===== SECURITY TESTS =====\r\n\r\n#[test]\r\nfn test_wrong_key_fails_decryption() {\r\n    // Test that decryption with wrong key fails\r\n    let plaintext = 5000 as Field;\r\n    let correct_key = Poseidon2::hash([111 as Field], 1);\r\n    let wrong_key = Poseidon2::hash([222 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, correct_key, counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, wrong_key, counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_wrong_counter_fails_decryption() {\r\n    // Test that decryption with wrong counter fails\r\n    let plaintext = 7777 as Field;\r\n    let key = Poseidon2::hash([333 as Field], 1);\r\n    let correct_counter = 2 as u32;\r\n    let wrong_counter = 3 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, correct_counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, key, wrong_counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_deterministic() {\r\n    // Test that same inputs always produce same ciphertext\r\n    let plaintext = 8888 as Field;\r\n    let key = Poseidon2::hash([444 as Field], 1);\r\n    let counter = 1 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, key, counter);\r\n    \r\n    // Same inputs should produce same ciphertext\r\n    assert(ciphertext1 == ciphertext2);\r\n}\r\n\r\n#[test]\r\nfn test_different_plaintexts_different_ciphertexts() {\r\n    // Test that different plaintexts produce different ciphertexts\r\n    let key = Poseidon2::hash([555 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(1000 as Field, key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(2000 as Field, key, counter);\r\n    let ciphertext3 = poseidon_ctr_encrypt(3000 as Field, key, counter);\r\n    \r\n    // Different plaintexts should produce different ciphertexts\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n}\r\n\r\n// ===== EDGE CASE TESTS =====\r\n\r\n#[test]\r\nfn test_max_counter_value() {\r\n    // Test with maximum counter value\r\n    let plaintext = 1234 as Field;\r\n    let key = Poseidon2::hash([666 as Field], 1);\r\n    let max_counter = 4294967295 as u32; // u32::MAX\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, key, max_counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, key, max_counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_preserves_field_arithmetic() {\r\n    // Test that encryption preserves field arithmetic properties\r\n    let a = 1000 as Field;\r\n    let b = 2000 as Field;\r\n    let key = Poseidon2::hash([777 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    // Encrypt individual values\r\n    let enc_a = poseidon_ctr_encrypt(a, key, counter);\r\n    let enc_b = poseidon_ctr_encrypt(b, key, counter);\r\n    \r\n    // Decrypt and verify\r\n    let dec_a = poseidon_ctr_decrypt(enc_a, key, counter);\r\n    let dec_b = poseidon_ctr_decrypt(enc_b, key, counter);\r\n    \r\n    assert(dec_a == a);\r\n    assert(dec_b == b);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_uniformity() {\r\n    // Test that keystreams appear uniformly distributed\r\n    let key = Poseidon2::hash([888 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(key, 0);\r\n    let keystream2 = poseidon_keystream(key, 1);\r\n    let keystream3 = poseidon_keystream(key, 2);\r\n    let keystream4 = poseidon_keystream(key, 3);\r\n    let keystream5 = poseidon_keystream(key, 4);\r\n    \r\n    // All keystreams should be different (very high probability)\r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream3 != keystream4);\r\n    assert(keystream4 != keystream5);\r\n    assert(keystream1 != keystream3);\r\n    assert(keystream1 != keystream4);\r\n    assert(keystream1 != keystream5);\r\n    assert(keystream2 != keystream4);\r\n    assert(keystream2 != keystream5);\r\n    assert(keystream3 != keystream5);\r\n}\r\n\r\n// ===== TEST FOR TYPESCRIPT COMPARISON =====\r\n\r\n/// Get test values for TypeScript comparison\r\npub fn get_poseidon_ctr_test_values() -> (Field, Field, Field, Field, Field, Field, Field, Field) {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Return all values for external testing\r\n    (amount, token_address, ref, encryption_key, encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n#[test]\r\nfn test_poseidon_ctr_encryption_values() {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Decrypt all fields\r\n    let decrypted_amount = poseidon_ctr_decrypt(encrypted_amount, encryption_key, 0);\r\n    let decrypted_token_address = poseidon_ctr_decrypt(encrypted_token_address, encryption_key, 1);\r\n    let decrypted_ref = poseidon_ctr_decrypt(encrypted_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(encrypted_key, encryption_key, 3);\r\n    \r\n    // Verify round-trip encryption/decryption\r\n    assert(decrypted_amount == amount);\r\n    assert(decrypted_token_address == token_address);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n \r\n    println(\"Encrypted amount: 0x{:x}\");\r\n    println(encrypted_amount);\r\n    println(\"Encrypted token address: 0x{:x}\");\r\n    println(encrypted_token_address);\r\n    println(\"Encrypted ref: 0x{:x}\");\r\n    println(encrypted_ref);\r\n    println(\"Encrypted key: 0x{:x}\");\r\n    println(encrypted_key);\r\n    println(\"Decrypted amount: 0x{:x}\");\r\n    println(decrypted_amount);\r\n    println(\"Decrypted token address: 0x{:x}\");\r\n    println(decrypted_token_address);\r\n    println(\"Decrypted ref: 0x{:x}\");\r\n    println(decrypted_ref);\r\n    println(\"Decrypted key: 0x{:x}\");\r\n    println(decrypted_key);\r\n}\r\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon-ctr-encryption/src/lib.nr"}},"names":["main"],"brillig_names":["field_less_than","decompose_hint","lte_hint","directive_invert","directive_integer_quotient"]}